### 1.应用优化

​		前面章节，介绍了很多数据库优化的措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的压力。

#### 1)使用连接池

​		对于访问数据来说，建立连接的代价是比较昂贵的。因为频繁创建和关闭连接是比较耗费资源的，所以有必要建立数据库连接池，提升访问的性能。

#### 2)减少对mysql的访问

##### 	1.避免重复检索

​		在编写引用代码时，需要能够理清对数据库的访问逻辑。能够通过一次连接就能获得的结果，就不要用两次。

```mysql
select id ,name from tb_book;
select id, status from tb_book;
#可以合并层一句话
select id ,name,status from tb_books;
```

##### 	2.增加cache层

​		在应用中，可以增加缓存层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能够满足应用需求就可以。

​		因此可以将部分数据从数据库抽取出来，放到应用端以文本方式存储，或者使用框架（Mybatis，Hibernate）提供的一级缓存、二级缓存，或者使用redis数据库来缓存数据。

#### 	3)负载均衡

​		负载均衡是应用中比较普遍的一种优化方法，它的机制是利用某种均衡算法，将固定的负载量分布到不同的服务器上，以此来降低单台服务器的负载，达到优化的效果。

* 方式一：利用Mysql的复制分流

  通过mysql的主从复制，实现读写分离，使**增、删、改**操作走主节点，**查询**操作走从节点，从而可以降低单台服务器的读写压力。

* 方式二：利用分布式数据架构

  分布式数据架构适合大数据量、负载高的情况。通过在多台服务器之间分布数据，可以实现多台服务器之间的负载均衡和数据保存，提高访问效率，提升数据的安全性。

![image-20210723140236649](..\_posts\images\image-20210723140236649.png)

### 2.Mysql查询缓存优化

#### 1）概述

开启Mysql的查询缓存，当执行==完全相同的SQL语句==的时候，服务器就会从缓存中读取结果。当数据被修改，之前的缓存就会失效。

**修改比较频繁的表不适合做查询缓存。**

#### 2）操作流程

<img src="..\_posts\images\image-20210723140846102.png" alt="image-20210723140846102" style="zoom: 60%;" />

#### 3）查询缓存配置

1. 查看当前数据库是否支持缓存

   ```mysql
   show variables like 'have_query_cache';
   ```

2. 查询当前Mysql是否开启缓存开关

   ```mysql
   show variables like 'query_cache_type';
   ```

3. 查询缓存的大小

   ```mysql
   show variables like 'query_cache_size'; # 查询出来额值，单位是字节
   ```

4. 查看查询缓存的状态信息

   ```mysql
   show status like 'Qcache%';
   ```

   | 参数                    | 含义                                                         |
   | ----------------------- | ------------------------------------------------------------ |
   | Qcache_free_blocks      | 查询缓存中的可用内存块数                                     |
   | Qcache_free_memory      | 查询缓存的可用内存量                                         |
   | **Qcache_hits**         | 查询缓存的命中数                                             |
   | **Qcache_inserts**      | 添加到查询缓存的查询数                                       |
   | Qcache_lowmen_prunes    | 由于内存不足而从查询内存中删除的查询数                       |
   | **Qcache_not_cached**   | 非缓存查询的数量（由于query_cache_type)设置而无法缓存或未缓存 |
   | Qcache_queries_in_cache | 查询缓存中注册的查询数                                       |
   | Qcache_total_blocks     | 查询缓存中得块总数4）开启查询缓存                            |

#### 4）开启查询缓存

Mysql查询缓存默认是关闭的，需要手动配置参数`query_cache_type`来开启查询缓存。

| 值        | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| OFF或0    | 查询缓存功能关闭                                             |
| ON或1     | 查询功能打开，SELECT结果**符合缓存条件**即缓存；显示指定SQL_NO_CACHE则不缓存 |
| DEMAND或2 | 查询缓存按需进行；显示指定SQL_CACHE的SELECT语句才会缓存      |

linux系统中，在/usr/my.cnf中配置

```shell
# 追加下面一行，开启查询缓存
query_cache_type=1
# 保存重启生效
```

#### 5）查询缓存SELECT选项

可以通过两个选项设置查询缓存：

SQL_CACHE ：如果查询结果是可缓存的，并且`query_cache_type`系统变量的值为ON或DEMAND，则缓存查询结果；

SQL_NO_CACHE：服务器不使用查询缓存。既不检查查询缓存，也不检查结果是够缓存，也不缓存查询结果。

```mysql
SELECT SQL_CACHE id,name FROM customer;
SELECT SQL_NO_CACHE id,name FROM customer;
```

#### 6）查询缓存失效的情况

##### 	1.SQL语句不一致

```mysql
select count(*) from  tb_item;
Select count(*) from tb_item;
#此时语句写的不一样（大小写）,则不会走查询缓存
```

##### 2.查询语句中内容不确定

​	如： now(), current_date(), curdate(), curtime(), rand(), uuid(), user(), database().

```mysql
select * from tb_item where updatetime<now() limit 1;
select user();
select databases;
```

##### 3.不使用任何表查询语句

```mysql
select 'A';
```

##### 4.查询系统数据库

​	如mysql、information_schema、performance_schema数据库中的表时，不走查询缓存。

```mysql
select * from infomation.engines;
```

##### 5.函数、触发器、事务内部

在函数、触发器、事务内部的主体内执行的查询，不走查询缓存

##### 6.表发生更改

如果表中数据发生变化，高速缓存查询会全部失效。

如表中使用下列操作：`update()`,`insert()`,`delete`,`truncate table`,`alter table`,`drop table`,`drop database`等。

### 3.Mysql内存管理及优化

#### 1）内存优化原则

1. 将尽量多的内存分配给Mysql做缓存，但要给操作系统和其他程序预留自购内存
2. MyISAM存储引擎的数据文件读取依赖于**操作系统自身的IO缓存**。因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。
3. 排序区、连接区等缓存是分配给每个数据库绘画（session）专用的，默认值需根据最大连接数合理分配。如果设置太大，不但浪费资源，而且在并发连接较高时会耗尽物理内存。

#### 2）MyISAM内存优化

MyISAM存储引擎使用key_buffer缓存索引块，加速MyISAM索引的读写速度。

对于MyISAM表的数据库，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。



**key_buffer_size**

key_buffer_size决定MyISAM索引块缓存区的大小，直接影响MyISAM表的存取效率。

可以在Mysql参数文件中设置key_buffer_size的值，提升性能。

在linux系统中，在/user/my.cnf中做如下配置

```mysql
# 查看
show variables like "key_buffer_size";
# 设置
# 对于一般的MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size
key_buffer_size = 512M
```

**read_buffer_size**

​		如果经常使用**顺序扫描**，可以通过增大read_buffer_size的值来改善性能。但是需要注意的是read_buffer_size是每个session独占的，如果设置过大，会造成内存浪费。

**read_rnd_buffer_size**

​		对于需要做**排序**的MyISAM表查询，如带有`order by`子句的sql，适当增加read_rnd_buffer_size的值可以改善性能。但是需要注意的是read_rnd_buffer_size是每个session独占的，如果设置过大，会造成内存浪费。

#### 3）InnoDB内存优化

​		InnoDB用一块内存区做IO缓存池，该缓存池不仅用来缓存InnoDB的索引块，而且也用来缓存InnoDB的数据块。

* **innodb_buffer_pool_size**

  该变量决定了InnoDB存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统和其他程序有足够内存情况下，增大innodb_buffer_pool_size的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O越少，性能越高。

  ```mysql
  # 在/usr/my.cnf中添加
  innodb_buffer_pool_size = 512M
  ```

* **innodb_log_buffer_size**

  决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。

  ```mysql
  # 在/usr/my.cnf中添加
  innodb_log_buffer_size = 10M
  ```

#### 4）Mysql并发参数调整

​	从实现上来说，Mysql Server是多线程的结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。

​	在Mysql中，控制并发连接和线程的主要参数包括 `max_connections`，`back_log`，`thread_cache_size`，`table_open_cache`

##### 		1.max_connetcions

​		采用`max_connections`控制允许连接到Mysql数据库的最大数量，默认值是151。

​		如果`connnection_errors_max_connections`不为0，且一直增长，则说明不断有连接请求因数据库连接数到达上限而连接失败，此时需要考虑增加`max_connection`的值。

​		Mysql最大可支持的连接数，取决于操作系统线程库的质量、内存大小、每个连接的负荷、CPU的处理速度、期望的相应时间等。在linux平台下，性能好的服务器可以支持500-1000个连接，需要根据服务器的性能进行评估设定。

##### 	2.back_log

​		back_log参数控制Mysql监听TCP端口设置的积压请求栈大小。

​		当mysql连接数达到max_connetions时，新来的请求会被存放在堆栈中，等待某一连接释放资源，这个堆栈就是back_log的。如果等待连接的数量超过back_log,将不会被授予连接资源，进而报错。

​		MySQL 5.6.6版本之前，back_log默认值是50；之后默认为max_connections/5，但不超过900。

​		如果需要数据库在较短时间内处理大量的连接请求，可以考虑增大back_log的值。

##### 3.table_open_cache

​		table_open_cache控制所有SQL语句执行线程可打开表缓存的数量。

​		一个SQL语句至少操作一张表，即至少打开一个表缓存。

​		该参数的值应该根据设置的最大连接数`max_connections`以及每个连接执行关联插叙中涉及的表的最大 数量来设定。

```mysql
# 查询
show variables like 'table_open_cache';
# 设置 max_connections x N 
```

##### 4.thread_cache_size

​		为了加快连接数据库的速度，Mysql会缓存一定数据的客户服务线程以备重用。

通过参数`thread_cache_size`可以控制Mysql缓存客户服务线程的数量。

```mysql
show variables like 'thread_cache_size';
```

##### 5.innodb_lock_wait_timeout

​		该参数用来设置innodb事务等待行锁的时间，默认值为50ms，可动态设置；

```mysql
show variables like 'innodb_lock_wait_timeout';
```

### 4.Mysql的锁

#### 1）概述

​		锁是计算机协调多个进程或线程并发访问某一资源的机制。【避免资源的争抢问题】

#### 2）锁分类

从对数据操作的粒度：

  		1. 表锁 ：操作时，会锁定整个表
  		2. 行锁：操作时，会锁定当前操作行

从对数据操作的类型分：

1. 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响
2. 写锁（排它锁）：当前操作没有完成之前，它会阻断其他**写锁**和**读锁**

#### 3）Mysql锁

相对其他数据库而言，Mysql的锁机制比较简单，其最显著的特点是不同存储引擎支持不同的锁机制。

| 存储引擎 | 表级锁 | 行级锁 | 页面锁 |
| -------- | ------ | ------ | ------ |
| MyISAM   | 支持   | 不支持 | 不支持 |
| InnoDB·  | 支持   | 支持   | 不支持 |
| MEMORY   | 支持   | 不支持 | 不支持 |
| BDB      | 支持   | 不支持 | 支持   |

Mysql中锁的特性：

| 锁特性 | 特点                                                         |
| ------ | ------------------------------------------------------------ |
| 表级锁 | 偏向MyISAM存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率最高，并发低 |
| 行级锁 | 偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生冲突的概率最低，并发最高 |
| 页面锁 | 开销和加锁时间介于表锁和 行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般 |

在不同的业务场景下，需要合理选用锁。

#### 4）MyISAM表锁

MyISAM存储引擎只支持表锁，这也是Mysql开始几个版本中唯一支持的锁类型。

##### 1.加锁操作

​		MyISAM在执行查询语句（SELECT)前，会自动给涉及的所有表加读锁。在执行更新操作（UPDATE,DELETE,INSERT等）前，会自动给涉及的表加写锁。

​		上述过程不需要用户显示加锁：

```mysql
# 加读锁
lock table table_name read;
# 加写锁
lock table table_name write;

# 解锁
unlock tables;
```

##### 2.读锁案例

* 读锁会阻塞写，不会阻塞读；【共享】

* 写锁既会阻塞写，也会阻塞读；【排他】

此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。

因为写锁后，其他线程不能做任何操作；大量的更新操作会导致查询很难得到锁，从而造成永久阻塞。

##### 3.查看锁的争用情况

```mysql
# 查看当前表的状态
show open tables;
```

<img src="..\_posts\images\image-20210723165802792.png" alt="image-20210723165802792" style="zoom:67%;" />

In_use: 如果该数为0，则说明表是打开的；

Name_lock: 表名是否被锁定。名称锁定用于取消表或对表进行重命名等操作

```mysql
show status like 'Table_locks%';
```

<img src="..\_posts\images\image-20210723165913614.png" alt="image-20210723165913614" style="zoom:67%;" />

Table_locks_immdiate :指的是能够立即获得表级锁、不出现阻塞等待的次数，，每立即获取锁一次，值加1；

Table_locks_waited: 指的是不能立即获取表级锁而等待的次数，每等待一次，值加1； 此值高，说明存在严重的表级锁争用情况。

#### 5）InnoDB行锁

##### 1.行锁介绍

操作时只锁定行，其他行可以被其他程序访问，所以锁定的粒度小。

InnoDB与MyISAM的最大不同点：

* 支持行锁
* 支持事务【原因就在于InnoDB采用行级锁】

##### 2.背景知识

事务是有一组由SQL语句组成的逻辑处理单元

事务具有ACID属性。原子性、一致性、隔离性、持久性。

事务处理带来的问题：脏读、幻读、不可重复读、丢失更新。

##### 3.InnoDB的行锁

InnoDB实现一下两种类型的行锁：

* 共享锁（S)：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，只能读不能写；
* 排它锁（X)：又称为写锁，简称X锁，排它锁就是不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的其他锁，包括共享锁和排它锁。此时，获取排它锁的事务就可以对锁进行读和写。

```mysql
# 对于UPDATE、DELETE、和INSERT语句，InnoDB会自动给涉及的数据集加上排他锁（X）
# 对于普通的SELECT语句，InnoDB不会加任何锁
```

加锁操作

```mysql
# 共享锁
select * from table_name where ... lock in share mode;
# 排它锁
select * from table_name where ... for update;

# 解锁,commit之后才算解锁，其他事务就可以操作了（对于同一行内容而言）
commit;
```

##### 4.行锁升级为表锁

如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。

**索引失效，行锁自动升级为表锁。** 具体失效情况参见高级【2】中得索引失效情况。

##### 5.间隙锁危害

当使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁。

对于键值在条件范围内但并不存在的记录，叫做间隙（GAP).

InnoDB会对这个间隙加锁，这种锁就是所谓的间隙锁（Next-Key锁）

```mysql
# 如 ID <5，在2和3之间有个间隙，这个地方会被自动加锁
1
2
 
4
set autocommit = 0;
# 先执行
update test_innodb set sex = 2 where id<4;
# 再执行下面语句是无效的，一来上面没有提交，行级锁锁住了；而来间隙锁存在，间隙锁锁住了。
update test_innodb set sex = 2 where id=3;
```

##### 6.InnoDB行锁争用情况

```mysql
show status like 'innodb_row_lock%';
```

![image-20210723183843578](..\_posts\images\image-20210723183843578.png)

| 项目                          | 说明                             |
| ----------------------------- | -------------------------------- |
| Innodb_row_lock_current_waits | 当前正在等待锁定的数量           |
| Innodb_row_lock_time          | 从系统启动到现在锁定总时间       |
| Innodb_row_lock_time_avg      | 每次等待消耗的平均时长           |
| Innodb_row_lock_time_max      | 从系统启动到现在等待解锁最长用时 |
| Innodb_row_lock_waits         | 从系统启动到现在总共等待次数     |

当等待次数多，等待时间长，就需要考虑优化了。

##### 7.总结

​		InnoDB默认使用行级锁定，虽然在锁定机制的实现方面带来了性能损失可能回避表锁更高一些，但是整体并发处理能力方面要远远优于MyISAM的表锁机制。

​		InnoDB的行锁机制也有脆弱的的一面，使用不当的情况下，InnoDB整体性能可能弱于MyISAM。

优化建议：

1. 尽可能让所有数据检索都能通过索引来完成，从而避免行锁升级为表锁
2. 合理设计索引，尽量缩小锁的范围
3. 尽可能减少索引条件及索引范围，避免间隙锁
4. 尽量控制事务大小，减少锁定资源量和时间长度
5. 尽可能使用低级别事务隔离【在满足业务层面的前提下】

### 5.常用SQL技巧

#### 1.SQL执行顺序

代码编写一般顺序：

```mysql
select distinct
	<select list>
from
	<left_table> <join type>
where
	<where_condition>
group by
	<group_by_list>
having
	<having_condition>
order by
	<order_by_condition>
limit
	<limit_params>
```

执行顺序

```mysql
from 			<left_table>
on   			<join_condition>
<join_type> 	join <right_table>
where 			<where_condition>
group by		<group_by_list>
having			<having_condition>
select distinct  <select list>
order by		<order_by_condition>
limit			<limit_params>	
```

#### 2.正则表达式

```mysql
select * from tb_book where name regexp '[^a]';
```

#### 3.Mysql常用函数

##### 数学函数

| 函数          | 功能                               |
| ------------- | ---------------------------------- |
| ABS(x)        | 返回x的绝对值                      |
| CEIL(x)       | 返回大于x的最小整数值              |
| FLOOR(x)      | 返回小于x的最大整数值              |
| MOD(x,y)      | 返回x/y的模                        |
| RAND()        | 返回 0～1内的随机值                |
| ROUND(x,y)    | 返回参数x的四舍五入的有y位小数的值 |
| TRUNCATE(x,y) | 返回数字x截断位y位小数的结果       |

##### 日期和时间函数

| 函数                              | 功能                                         |
| --------------------------------- | -------------------------------------------- |
| CURDATE()                         | 返回当前日期                                 |
| CURTIME()                         | 返回当前时间                                 |
| NOW()                             | 返回当前的日期和时间                         |
| UNIX_TIMESTAMP(date)              | 返回日期date的UNIX时间戳                     |
| FROM_UNIXTIME                     | 返回UNIX时间戳的日期值                       |
| WEEK(date)                        | 返回日期date为一年中的第几周                 |
| YEAR(date)                        | 返回日期date的年份                           |
| HOUR(time)                        | 返回time的小时值                             |
| MINUTE(time)                      | 返回time的分钟值                             |
| MONTHNAME(date)                   | 返回date的月份名                             |
| DATE_FORMAT(date,fmt)             | 返回按字符串fmt格式日期date值                |
| DATE_ADD(date,interval expr type) | 返回一个日期或时间值加上一个时间间隔的时间值 |
| DATEDIFF(expr,expr2)              | 返回起始时间expr和结束时间expr2之间的天数    |

##### 字符串函数

| 函数                  | 功能                                         |
| --------------------- | -------------------------------------------- |
| CONCAT(s1,s2,....)    | 字符串连接                                   |
| INSERT(str,x,y,instr) | 将指定开始标记到结束的字符串替换为指定字符串 |
| LOWER(str)            | 将字符串所有字符转为小写                     |
| UPPER(str)            | 将字符串所有字符串转为大写                   |
| LEFT(str,x)           | 返回字符串str最左边的x个字符                 |
| RIGHT(str,x)          | 返回字符串str最右边的x个字符                 |
| LPAD(str,n,pad)       | 在str最左边填充n个pad                        |
| RPAD(str,n,pad)       | 在str最右边填充n个pad                        |
| LTRIM(str)            | 去掉字符串str左侧的空格                      |
| RTRIM(str)            | 去掉字符串str右侧的空格                      |
| REPEAT(str,x)         | 返回str重复x次的结果                         |
| STRCMP(s1,s2)         | 比较字符串s1和s2                             |
| REPLACE(str,a,b)      | 用字符串b替换字符串str中所有出现的字符串a    |
| TRIM(str)             | 去掉字符串行尾和行头的空格                   |
| SUBSTRING(str,x,y)    | 返回从字符串str x位置起y个字符长度的字串     |

##### 其他常用函数

| 函数           | 功能                    |
| -------------- | ----------------------- |
| DATEBASE()     | 返回当前数据库名        |
| VERSION()      | 返回当前数据库版本      |
| USER()         | 返回当前登录用户名      |
| INET_ATON(ip)  | 返回ip地址的数字表示    |
| INET_NTOA(num) | 返回数字代表的ip地址    |
| PASSWORD(str)  | 返回字符串str的加密版本 |
| MD5()          | 返回字符串str的md5值    |

##### 聚合函数

| 函数  | 功能                         |
| ----- | ---------------------------- |
| MAX   | 查询指定列最大值             |
| MIN   | 查询指定列最小值             |
| COUNT | 统计查询结果的行数           |
| SUM   | 求和，返回指定列的总和       |
| AVG   | 求平均值，返回指定列的平均值 |

```mysql
select lower('AAA');
select left('pythonhello',5); # 截取字符串
select current_time();
select max(id) from tb_book);
```

