---
title: 数据库前后端分离
layout: post
tags: 数据库
categories: ''
---

## 一、主要矛盾

随着应用业务数据不断的增大，应用的 响应速度不断下降，在检测过程中我们不难发现大多数的请求都是 查询操作。此时，我们可以将数据库扩展成 主从复制模式，将 读操作 和 写操作 分离开来，多台数据库 分摊请求，从而 减少单库 的 访问压力，进而应用得到优化。

数据库读写时刻相同时，出现数据库崩溃的状况，此时就需要对数据库进行读写分离操作。

**1、why 那么为什么要读写分离呢？**
因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。
但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。
所以读写分离，解决的是，数据库的写入，影响了查询的效率。

2**、when 什么时候要读写分离？**
数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。

## 二、主从复制的方式

MySQL 5.6 开始主从复制有两种方式：基于日志（binlog）和 基于 GTID（全局事务标示符）。

本文只涉及基于日志 binlog 的 主从配置。

## 三、主从复制的流程

MySQL 同步操作通过 3 个线程实现，其基本步骤如下：

1. 主服务器 将数据的更新记录到 二进制日志（Binary log）中，用于记录二进制日志事件，这一步由 主库线程 完成；

2. 从库 将 主库 的 二进制日志 复制到本地的 中继日志（Relay log），这一步由 从库 I/O 线程 完成；

3. 从库 读取 中继日志 中的 事件，将其重放到数据中，这一步由 从库 SQL 线程 完成。

## 四、主从模式的优点

1. 负载均衡
通常情况下，会使用 主服务器 对数据进行 更新、删除 和 新建 等操作，而将 查询 工作落到 从库 头上。

2. 异地容灾备份
可以将主服务器上的数据同步到 异地从服务器 上，极大地提高了 数据安全性。

3. 高可用
数据库的复制功能实现了 主服务器 与 从服务器间 的数据同步，一旦主服务器出了 故障，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。

4. 高扩展性
主从复制 模式支持 2 种扩展方式:

```
scale-up
向上扩展或者 纵向扩展，主要是提供比现在服务器 性能更好 的服务器，比如 增加 CPU 和 内存 以及 磁盘阵列等，因为有多台服务器，所以可扩展性比单台更大。
```

```
scale-out
向外扩展或者 横向扩展，是指增加 服务器数量 的扩展，这样主要能分散各个服务器的压力。

```

## 五、主从模式的缺点

1. 成本增加
搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 二进制日志，所以也会造成额外的 性能消耗。

2. 数据延迟
从库 从 主库 复制数据肯定是会有一定的 数据延迟 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 主库 中查询出来，当然这个也是需要用代码来控制的。

3. 写入更慢
主从复制 主要是针对 读远大于写 或者对 数据备份实时性 要求较高的系统中。因为 主服务器 在写中需要更多操作，而且 只有一台 可以写入的 主库，所以写入的压力并不能被分散。

主从复制的前提条件

1. 主从服务器 操作系统版本 和 位数 一致。

2. 主数据库和从数据库的 版本 要一致。

3. 主数据库和从数据库中的 数据 要一致。

4. 主数据库 开启 二进制日志，主数据库和从数据库的 server_id 在局域网内必须 唯一。

   

## 六、具体配置

### 1. 环境准备

| 名称           | 版本号  |
| -------------- | ------- |
| Docker         | 20.10.2 |
| Docker Compose | 1.28.6  |
| MySQL          | 5.7.17  |

### 2. 配置docker-compose.yml

docker-compose.yml

```yaml
version: '2'
services:
  mysql-master:
    build:
      context: ./
      dockerfile: master/Dockerfile
    environment:
      - "MYSQL_ROOT_PASSWORD=root"
      - "MYSQL_DATABASE=replicas_db"
    links:
      - mysql-slave
    ports:
      - "33065:3306"
    restart: always
    hostname: mysql-master
  mysql-slave:
    build:
      context: ./
      dockerfile: slave/Dockerfile
    environment:
      - "MYSQL_ROOT_PASSWORD=root"
      - "MYSQL_DATABASE=replicas_db"
    ports:
      - "33066:3306"
    restart: always
    hostname: mysql-slave
```

### 3. 主数据库配置

#### 3.1. 配置Dockerfile

Dockerfile

```dockerfile
FROM mysql:5.7.17
MAINTAINER harrison
ADD ./master/my.cnf /etc/mysql/my.cnf
```

#### 3.2. 配置my.cnf文件

my.cnf

```mysql
[mysqld]
## 设置server_id，一般设置为IP，注意要唯一
server_id=100  
## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）
binlog-ignore-db=mysql  
## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）
log-bin=replicas-mysql-bin  
## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存
binlog_cache_size=1M  
## 主从复制的格式（mixed,statement,row，默认格式是statement）
binlog_format=mixed  
## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。
expire_logs_days=7  
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
```

### 4. 从数据库配置

#### 4.1. 配置Dockerfile

```dockerfile
FROM mysql:5.7.17
MAINTAINER harrison
ADD ./slave/my.cnf /etc/mysql/my.cnf
```

#### 4.2. 配置my.cnf文件

```mysql
[mysqld]
## 设置server_id，一般设置为IP，注意要唯一
server_id=101  
## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）
binlog-ignore-db=mysql  
## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用
log-bin=replicas-mysql-slave1-bin  
## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存
binlog_cache_size=1M  
## 主从复制的格式（mixed,statement,row，默认格式是statement）
binlog_format=mixed  
## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。
expire_logs_days=7  
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062  
## relay_log配置中继日志
relay_log=replicas-mysql-relay-bin  
## log_slave_updates表示slave将复制事件写进自己的二进制日志
log_slave_updates=1  
## 防止改变数据(除了特殊的线程)
read_only=1  

```

### 5. 创建容器

进入 `docker` 目录，运行 `docker-compose` 启动命令。

```
docker-compose up -d
```

https://blog.csdn.net/abcde123_123/article/details/106244181

https://blog.csdn.net/mbytes/article/details/86711508



## 七、传统的两个镜像之间的配置

### 1.拉取docker mysql镜像

![image-20210403091642384](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403091642384.png)

### 2.使用拉取的mysql镜像构建主从容器

Master

```
docker run -p 3301:3306 --name mysql-master -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.23
```

Slave

```
docker run -p 3302:3306 --name mysql-slave -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.23
```

![image-20210403091751186](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403091751186.png)

![image-20210403092413209](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403092413209.png)

Master对外映射的端口号是3301，Slave对外映射的端口号是3302，大家可以自己随意设置。因为docker容器是相互隔离的，每个容器有其独立的IP地址，所以不同容器使用相同的端口并不会冲突。如果是在生产环境，肯定是在不同的机器上安装MySQL，相对来说会简单一些。

容器启动完成后，可以通过MySQL连接工具进行连接测试，看是否能成功

### 3.配置主容器Master

3.1 进入master容器

```
# mysql-master为容器名称
docker exec -it mysql-master /bin/bash		
```

3.2 在master容器安装vim

```
apt-get update
apt-get install vim
```

3.3 编辑master容器下的`my.cnf`文件

文件夹路径

```
cd /etc/mysql
```

![image-20210403092955937](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403092955937.png)

```
[mysqld]
## 同一局域网内注意要唯一
server-id=111
## 开启二进制日志功能，可以随便取（关键）
log-bin=master-bin    //master的log文件名
binlog-format=ROW     // 二级制日志格式，有三种 row，statement，mixed
binlog-do-db=数据库名  //同步的数据库名称,如果不配置，表示同步所有的库
```

在这个地方，需要建立一个数据库，如data_test，将其中的  “数据库名”  改为 data_test ；本案例直接在nvicat中建立

![image-20210403093712299](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403093712299.png)

![image-20210403093820650](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403093820650.png)

退出容器，并重启容器；重新进入master容器-> 进入mysql->在master容器中建立同步用户slave->授权

```
docker restart mysql-master
```

```
docker exec -it mysql-master /bin/bash
```

```
mysql> CREATE USER 'slave'@'%' IDENTIFIED BY '123456';
Query OK, 0 rows affected (0.00 sec)

mysql>  GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';
Query OK, 0 rows affected (0.01 sec)
mysql> FLUSH PRIVILEGES;   #刷新权限 
```

查看master的状态，其中的File和Postion需要记住，后面主从复制需要用到

```
mysql > show master status;
```

![image-20210403094406879](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403094406879.png)

至此，Master的配置结束，别动它了！

### 4.配置从容器Slave

步骤： 

1. 进入从容器slave

   ```
   docker exec -it mysql-slave /bin/bash
   ```

2. 安装vim

   ```
   apt-get update
   apt-get install vim
   ```

3. 修改从容器中的my.cnf文件

   ```
   cd /etc/mysql
   vim my.cnf
   ```

   ```
   [mysqld]
   ## 设置server_id,注意要唯一
   server-id=222
   ## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用
   log-bin=mysql-slave-bin   
   ## relay_log配置中继日志
   relay_log=mysql-relay-bin  
   read_only=1  ## 设置为只读,该项如果不设置，表示slave可读可写
   ```

   配置完成后也需要重启docker容器。

### 5. 主从复制

1. 重新进入Slave容器中

   master_host -- 主容器的ip

   ```
   # 查找ip
   docker inspect mysql-master |grep IPAddress
# 下面这个更加明了一点
   docker inspect --format='{{.NetworkSettings.IPAddress}}' mysql-master
```
   
![image-20210403095859188](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403095859188.png)
   
master_user -- 为在Master中创建的同步用户，前面已经创建了，为slave
   
master_log_file -- 为前面需要记住的File，指定 Slave 从哪个日志文件开始复制数据
   
   master_log_pos -- 为前面需要记住的Position，指从哪个 Position 开始读
   
   master_connect_retry -- 如果连接失败，重试的时间间隔，单位是秒，默认是60秒

```
change master to master_host='172.17.0.3', master_user='slave', master_password='123456', master_port=3306, master_log_file='master-bin.000001', master_log_pos=934, master_connect_retry=30;
```

​	2. 查看slave状态

```
show slave status \G
```

![image-20210403100444835](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403100444835.png)

3. 开启主从复制

   使用`start slave;`开启主从复制过程，然后再次查询主从同步状态`show slave status \G`;。

![image-20210403100809998](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403100809998.png)

使用`start slave`开启主从复制过程后，如果`SlaveIORunning`一直是`Connecting`，则说明主从复制一直处于连接状态，这种情况一般是下面几种原因造成的，我们可以根据 `Last_IO_Error`提示予以排除。

![image-20210403100854572](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403100854572.png)

在解决这个错误的时候，由于是8.0版本，需要在主容器Master中，

查看主库：

```
mysql >use mysql;
mysql> SELECT plugin FROM `user` where user = 'slave';
```

原来是主库slave的plugin是caching_sha2_password 导致连接不上，修改成为mysql_native_password即可解决。

```
ALTER USER 'slave'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
```


原文链接：https://blog.csdn.net/u012483153/article/details/114484769

![image-20210403103418889](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403103418889.png)

### 6. 主从复制测试

进行mysql的主从复制有很多方式，此处我们进行一个简单的测试。

![image-20210403114543091](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210403114543091.png)

### 7.错误集锦

1. 主从库不一致时，如Master中存在的数据库 book，而从库中没有，此时删除库就会出现1008错误或者其他代码啊错误；

   解决方案，在slave的my.cnf中加入下面的语句，跳过错误

   ```
   slave_skip_errors=1146,1008
   ```

   重启Slave就ok了

2. Master和Slave都关机后，重新启动，如果是随机分配地址，需要保证Master的ip地址和以前设定的一样；

   docker重新启动可以使用先后启动Master和Slave的方式，保证与之前相同的ip分配；

   虚拟机的分配也是一样，保证主库的虚拟机和之前的ip地址相同。