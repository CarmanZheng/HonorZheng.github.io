---
title: 网络编程
layout: post
tags: 网络通信
categories: ''
---

## 网络编程【SOCKET通信】

【2021-06-29】

#### 1.1 概述

**计算机网络：**

计算机网络系统就是利用通信设备和线路将==地理位置不同==、功能独立的==多个计算机==系统互联起来，以功能完善的[网络软件](https://baike.baidu.com/item/网络软件/708424)实现网络中资源共享和信息传递的系统。通过计算机的互联，实现计算机之间的通信，从而实现计算机系统之间的信息、软件和设备资源的共享以及协同工作等功能，其本质特征在于提供计算机之间的==各类资源的高度共享==，实现便捷地交流信息和交换思想。

**网路编程的目的：**

传播交流信息

**想要达到的这个效果需要什么：**

1. 如何准确的定位网络上的一台主机 ，如ip 192.168.4.24:端口，定位到这个计算机上的某个资源

2. 找到了这个主机，如何传输数据？

   TCP/IP 网络传输

#### 1.2 网络通信的要素

如何实现网络的通信？

- 通信双方的地址： ip号：端口号，如 192.168.4.24:5000
- 规则：网络通信协议【TCP/IP参考模型】

<img src="..\_posts\images\image-20210629163937721.png" alt="image-20210629163937721" style="zoom: 67%;" />

小结：

1. 网络编程中有两个主要的问题
   * 如何准备的定位到网络上的一台或者多台主机
   * 找到 主机之后如何进行通信
2. 网络编程中的要素
   * IP和端口号
   * 网络通信协议
3. 万物皆对象

#### 1.3 IP 地址

* 唯一定位一台网络上的计算机

* 127.0.0.1 为本机localhost

* ip分类：

  *  IPv4/IPv6
    * ==IPv4== 127.0.0.1 ，4个字节，组成0~255，供约42亿
    * ==IPv6==  fe80:aaaa:e4bb:75ff:fe6e:f82e:bbbb:cccc ， 128位。8个无符号整数

  * 公网【互联网】/私网【局域网】
    * ABCD类地址
    * 192.168.xx.xx专门给组织内部使用

* 域名：记忆ip问题

  * IP ,如 www.vip.com

  ```python
  >>> import socket
  >>> print(socket.gethostbyname(socket.gethostname()))
  '192.168.157.1'
  ```

#### 1.4 端口

端口表示计算机上的一个程序的进程

* 不同的进程有不同的端口号！ 用来区分软件！

* 被规定0~65535

* TCP,UDP每个协议都有65535个，所以使用TCP的80端口时，UDP的80端口不受影响

* 端口分类

  * 公有端口 0~1023

    * HTTP: 80
    * HTTPS: 443
    * FTP: 21
    * Talent： 23

  * 程序注册端口：1024~49151，分配用户或者程序

    * Tomcat ： 8080
    * MySQL:    3306
    * Oracle：   1521

  * 动态、私有： 49152~65535

    ```
    netstat -ano # 查看所有的端口
    netstat -ano|findstr"5900"
    ```


#### 1.5  通信协议

协议：protocol 

**网络通信协议**：速率、传输码率、代码结构、传输控制

**TCP UDP** 对比：

* TCP相当于打电话：
  * 连接稳定

  * ==三次握手四次挥手==

    ```shell
    # 最少需要三次，保证稳定连接
    A:你愁啥？
    B:瞅你咋滴？
    A:干一场！
    
    # TCP协议发起是全双工协议，所有在Client发起请求之后，Server端表示同意，【单工建立】；
    # 同时，Server端发起请求，Client表示同意，并告知Server 【双工建立】
    
    # 四次挥手
    A: 我要走了
    B: 你真的要走了吗？
    B: 你真的真的要走了吗？
    A: 我真的真的要走了
    
    # Client 发起断开链接请求，Server端表示同意；此时C -> S TCP通道断开  【两次挥手】
    # 此时 S->C依然能够单工通信
    # Server端发起断开链接请求，Client端表示同意；此时S->C TCP通道断开 【两次挥手】
    # 此时，双工通道完全断开，四次挥手完成
    ```
  
  * 传输完成、释放连接
  
* UDP相当于发短信

  * 不连接、不稳定

#### 1.6 TCP

##### **1.收发结构**

​	网络编程的时候需要写两个部分：

* ​	客户端
  1. 连接服务器Socket
  2. 发送消息
* ​    服务端
  1. 建立服务端口的SeverSocket
  2. 等待用户的链接accept
  3. 接收用户的消息



<img src="..\_posts\images\image-20210702095854465.png" alt="image-20210702095854465" style="zoom: 67%;" />

##### **2.消息边界**

​	对于TCP协议传输信息的程序来说，格式定义一定要明确规定==消息的边界==。因为TCP协议是==字节流（bytes  stream）协议==，如果消息中没有指定边界或者长度，接收方就不知道一个完整的消息从字节流的起止位置。

方式： 

* 用特殊字节作为消息的结尾符号

  如使用字节串FFFFFF作为结尾字符

* 在消息开头某个位置，直接指定消息的长度

**文件上传**

此处请使用python socket实现

#### 1.7 UDP

##### **1.消息边界**

​	UDP不需要指定消息边界，因为UDP是==数据报协议==，应用接收到的必定是发送方发送的完整消息。

#### 1.8 URL下载网络资源



## 网络编程【Python SOCKET通信】

#### 2.1 概述

所有计算机网络通讯程序的底层就是Socket编程接口，如http请求，其request库底层也是使用的socket编程接口。

socket是==应用层==与==TCP/IP协议族==通信的中间软件抽象层

<img src="..\_posts\images\image-20210702082853551.png" alt="image-20210702082853551" style="zoom:67%;" />

#### 2.2 python Socket库

聊天室代码 【代码可直接粘贴使用】

注意，下面的代码均为UDP通讯，

* 不需要监听，不需要连接；

* 启动服务后，只能被动等待客户消息； 

* 消息回复的时候，不仅需要发送消息，还需要填写对方地址

如果使用TCP链接，会一直占用通道，只能与一个人交流；

* 需要listen
* 需要accept

server.py

```python
import socket
import logging

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # 创建socket对象

    addr = ('0.0.0.0', 9999)
    s.bind(addr)  # 绑定地址和端口

    logging.info('UDP Server on %s:%s...', addr[0], addr[1])

    user = {}  # 存放字典{addr:name}
    while True:
        try:
            data, addr = s.recvfrom(1024)  # 等待接收客户端消息存放在2个变量data和addr里
            if not addr in user:  # 如果addr不在user字典里则执行以下代码
                for address in user:  # 从user遍历数据出来address
                    s.sendto(data + ' 进入聊天室...'.encode('utf-8'), address)  # 发送user字典的data和address到客户端
                user[addr] = data.decode('utf-8')  # 接收的消息解码成utf-8并存在字典user里,键名定义为addr
                continue  # 如果addr在user字典里，跳过本次循环

            if 'EXIT'.lower() in data.decode('utf-8'):#如果EXIT在发送的data里
                name = user[addr]   #user字典addr键对应的值赋值给变量name
                user.pop(addr)      #删除user里的addr
                for address in user:    #从user取出address
                    s.sendto((name + ' 离开了聊天室...').encode(), address)     #发送name和address到客户端
            else:   
                print('"%s" from %s:%s' %(data.decode('utf-8'), addr[0], addr[1]))  
                for address in user:    #从user遍历出address
                    if address != addr:  #address不等于addr时间执行下面的代码
                        s.sendto(data, address)     #发送data和address到客户端

        except ConnectionResetError:
            logging.warning('Someone left unexcept.')

if __name__ == '__main__':
    main()
```

client.py

```python
#clinet.py
import socket
import threading

def recv(sock, addr):
    '''
    一个UDP连接在接收消息前必须要让系统知道所占端口
    也就是需要send一次，否则win下会报错
    '''
    sock.sendto(name.encode('utf-8'), addr)
    while True:
        data = sock.recv(1024)
        print(data.decode('utf-8'))


def send(sock, addr):
    '''
        发送数据的方法
        参数：
            sock：定义一个实例化socket对象
            server：传递的服务器IP和端口
    '''
    while True:
        string = input('')
        message = name + ' : ' + string
        data = message.encode('utf-8')
        sock.sendto(data, addr)
        if string.lower() == 'EXIT'.lower():
            break

def main():
    '''
        主函数执行方法，通过多线程来实现多个客户端之间的通信
    '''
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server = ('127.0.0.1', 9999)
    tr = threading.Thread(target=recv, args=(s, server), daemon=True)
    ts = threading.Thread(target=send, args=(s, server))
    tr.start()
    ts.start()
    ts.join()
    s.close()

if __name__ == '__main__':
    print("-----欢迎来到聊天室,退出聊天室请输入'EXIT(不分大小写)'-----")
    name = input('请输入你的名称:')
    print('-----------------%s------------------' % name)
    main()
```

##### 1.黏包现象

​	基于tcp远程数据传输，如果发送数据过大，一次无法接收完，第二次接收的时候，会将第一次为接收完的内容继续接收过来，这就是黏包现象。

​	基于udp协议远程数据传输，如果发送数据过大，一次性发完之后，**不会出现黏包现象**；如果数据过大，超出的部分直接丢掉。

##### 2.黏包成因

​	tcp协议发送端缓冲区长度大于网卡的MTU（Maximum Transmission Unit）时，TCP会将这次发送的数据拆成几个数据包发送出去。

​	tcp建立一条连接通道，为数据流协议，因此不存在包大小的限制(暂不考虑缓冲区的大小)，这里指的是用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送；如果比较短，可能会等待和下一次数据一起发送。

##### 3.解决黏包问题

​	方法1：确定一次需要传输数据的大小，调整buffer，让其足够大，满足传输需求。

​				大文件的传输，一定是按照字节读，每次读固定的字节；

​				传输过程中，发送方一边读一边传，接收方一边收一边写；

​	缺点：多了一次交互，就是需要双方都知道数据有多大，send方和recv方都知道。

​	方法2： **struct模块** -- 可以把一个类型的数据转换成固定长度的bytes。

​				 这样就可以提前知道了需要接收的数据长度，将其使用struct进行封装，让双方都知道长度

server.py 【可粘贴使用】

```python
import struct
import socket
sk = socket.socket()
sk.bind(('127.0.0.1',8080))
sk.listen()
conn,addr = sk.accept()
while True:
    cmd = input(">>>")
    # 在server端输入指令，在client处理后返回结果到server端显示
    if cmd == 'q':
        conn.send(b'q')
        break
    conn.send(cmd.encode('gbk'))
    num = conn.recv(4)
    num = struct.unpack('i',num)[0]
    res = conn.recv(int(num)).decode('gbk')
    print(res)
conn.close()
sk.close()
```

client.py

```python
import struct
import socket
import subprocess

sk = socket.socket()
sk.connect(('127.0.0.1',8080))
while True:
    cmd = sk.recv(1024).decode('gbk')
    if cmd =='q':
        break
    print('server端传来的指令是%s'%cmd)
    res = subprocess.Popen(cmd,shell=True,
                          stdout = subprocess.PIPE,
                          stderr = subprocess.PIPE)
    std_out = res.stdout.read()
    std_err = res.stderr.read()
    len_num = len(std_out)+len(std_err)
    num_by = struct.pack('i',len_num)
    sk.send(num_by)
    sk.send(std_out)
    sk.send(std_err)
sk.close()
```

##### 4.大文件上传

server.py

```python
import socket
import struct
import json

sk = socket.socket()

sk.bind(("127.0.0.1",9000))
sk.listen()
buffer = 4096
conn,addr = sk.accept()

head_len= conn.recv(4)
head_len = struct.unpack('i',head_len)[0]
json_head = conn.recv(head_len).decode('utf-8')
head = json.loads(json_head)
filesize = head['filesize']

with open('new'+head['filename'],'wb') as f:
    while filesize:
        print(filesize)
        if filesize >= buffer:
            content = conn.recv(buffer)
            f.write(content)
            filesize -= buffer
        else:
            content = conn.recv(filesize)
            f.write(content)
            break
conn.close()
sk.close()
```

client.py

```python
import socket
import struct
import os
import json

sk = socket.socket()
sk.connect(("127.0.0.1",9000))
buffer = 4096
head ={'filepath':r'D:\03_Tiktok\监考项目','filename':'meetclient.zip','filesize':None}
file_path = os.path.join(head['filepath'],head['filename'])
head['filesize']= os.path.getsize(file_path)
filesize = head['filesize']
json_head = json.dumps(head)
bytes_head = json_head.encode('utf-8')

# 计算报头长度
head_len = len(bytes_head)
pack_len = struct.pack('i',head_len)

sk.send(pack_len)
sk.send(bytes_head)

with open(file_path,'rb') as f:
    while filesize:
        print(filesize)
        if filesize >= buffer:
            content = f.read(buffer)
            sk.send(content)
            filesize -= buffer
        else:
            content = f.read(filesize)
            sk.send(content)
            break
sk.close()
```

##### 5.SocketServer

​	启动server为多个client提供服务



#### 2.3 hashlib库

讲解地址 https://www.bilibili.com/video/BV13t411x7Wk?from=search&seid=7822383279718233717

​		hashlib模块是个专门提供hash算法的库，里面包括md5(), sha1(), sha224(), sha256(), sha384(), sha512(), blake2b(), blake2s()等。

```python
import hashlib
m = hashlib.md5()
m.update(b"Nobody inspects")
m.update(b" the spammish repetition")
print(m.digest())
print(m.hexdigest())

b'\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'
bb649c83dd1ea5c9d9dec9a18df0ffe9
```

md5 算法是目前使用最为广泛的算法； 如果使用sha算法，加密性能强，当然存储的空间相应加大了。

```python
import hashlib
sha = hashlib.sha1()
sha.update(b"Nobody inspects")
sha.update(b" the spammish repetition")
print(sha.digest())
print(sha.hexdigest())

b'S\x1b\x07\xa0\xf5\xb6dw\xa2\x17B\xd2\x82qv&OK\xbf\xe2'
531b07a0f5b66477a21742d2827176264f4bbfe2
```

##### 1.md5设置注册和登录

注册.py

```python
import hashlib
usr = input('username:')
pwd  = input('password:')
role = input('role:')

md5 = hashlib.md5()
md5.update(bytes(pwd,encoding='utf-8'))  # 注意，此处必须是bytes类型
md5_pwd = md5.hexdigest()
with open('userinfo','a') as file:
    if file:
        file.write('\n{}|{}|{}'.format(usr,md5_pwd,role))
    else:
         file.write('{}|{}|{}'.format(usr,pwd,role))
```

登录.py

```python
import hashlib
usr = input('username:')
pwd  = input('password:')
md5 = hashlib.md5()
md5.update(bytes(pwd,encoding='utf-8'))
md5_pwd = md5.hexdigest()
with open('userinfo') as file:
    for line in file:
        user,passwd,role = line.split('|')
        if usr == user and passwd == md5_pwd:
            print('登录成功')
```

md5摘要算法中，相同字符加密后的加密字符是相同的，这样就会出现撞库的危险【穷尽所有组合后并形成库，这样可以实现破解】

可以使用加盐算法、动态加盐算法加密

##### 2.文件一致性校验

```python
# update可以实现多次，而且和组合在一起摘要算法出来的值相同 
# 即下面的算啊和 md.update(b'alex2021')相同
import hashlib	
md5 = hashlib.md5()
md5.update(b'alex')
md5.update(b'2021')
md5_pwd = md5.hexdigest()
```

基于此算法，我们可以抽取文件内容的不用位置的字符串进行多次分别校验，并比对。

<img src="..\_posts\images\image-20210702141702180.png" alt="image-20210702141702180" style="zoom:80%;" />

#### 2.4 logging库-日志模块

##### 1.日志

​	日志是用来记录用户行为或者代码的执行过程

* python logging模块有5种模式： debug、info、warning、error、critical
* 两种配置方式：basicconfig方式、log对象方式

##### 2.basicconfig方式

参考链接 ：https://www.cnblogs.com/xianyulouie/p/11041777.html

```python
import logging  # 引入logging模块
# 配置日志需要显示的项【这种写法暂时支持中文输出，因为不能设置中文编码】
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s',
                    filename = 'test.log')  # logging.basicConfig函数对日志的输出格式及方式做相关配置
# 由于日志基本配置中级别设置为DEBUG，所以一下打印信息将会全部显示在控制台上
logging.info('this is a loggging info message')
logging.debug('this is a loggging debug message')
logging.warning('this is loggging a warning message')
logging.error('this is an loggging error message')
logging.critical('this is a loggging critical message')
```

运行后,在test.log文件中：

```
2021-07-02 14:55:38,754 - 记录日志.py[line:5] - INFO: this is a loggging info message
2021-07-02 14:55:38,757 - 记录日志.py[line:6] - DEBUG: this is a loggging debug message
2021-07-02 14:55:38,757 - 记录日志.py[line:7] - WARNING: this is loggging a warning message
2021-07-02 14:55:38,757 - 记录日志.py[line:8] - ERROR: this is an loggging error message
2021-07-02 14:55:38,757 - 记录日志.py[line:9] - CRITICAL: this is a loggging critical message
```

##### 3.log对象方式【推荐】

通过下面的配置，能够灵活处理中文

```python
import logging
logger = logging.getLogger()
# 设定日志输出文件格式，这里设定编码格式为 utf-8，支持中文
fh = logging.FileHandler('log.log',encoding = 'utf-8')
# 设定屏幕控制对象，用于日志的屏幕输出
sh = logging.StreamHandler()

# 独立设定输出格式
formatter01 = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')

formatter02 = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] : %(message)s')

# 绑定格式
fh.setFormatter(formatter01)
sh.setFormatter(formatter02)

# 关联对象
logger.addHandler(fh)
logger.addHandler(sh)

logging.info('this is a loggging info message')
logging.debug('this is a loggging debug message')
logging.warning('警告错误')
logging.error('错误')
logging.critical('this is a loggging critical message')
```

##### 4.配置参数

```
%(name)s 记录器的名称 
%(levelno)s 数字形式的日志记录级别 
%(levelname)s 日志记录级别的文本名称 
%(filename)s 执行日志记录调用的源文件的文件名称 
%(pathname)s 执行日志记录调用的源文件的路径名称 
%(funcName)s 执行日志记录调用的函数名称 
%(module)s 执行日志记录调用的模块名称 
%(lineno)s 执行日志记录调用的行号 
%(created)s 执行日志记录的时间 
%(asctime)s 日期和时间 
%(msecs)s 毫秒部分 
%(thread)d 线程ID 
%(threadName)s 线程名称 
%(process)d 进程ID 
%(message)s 记录的消息
```

##### 5.内置处理器

前面使用了FileHandler对象，可以将log写入本地文件；StreamHandler可以将log写入控制台；

下面有一些内置处理器，可以将日志写入不同的远方~

```
内置处理器
logging模块提供了一些处理器，可以通过各种方式处理日志消息。使用addHandler()方法将这些处理器添加给Logger对象。另外还可以为每个处理器配置它自己的筛选和级别。 
logging.StreamHandler 可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息 
logging.FileHandler 将日志消息写入文件filename。 
logging.handlers.DatagramHandler(host，port) 发送日志消息给位于制定host和port上的UDP服务器。使用UDP协议，将日志信息发送到网络 
logging.handlers.HTTPHandler(host, url) 使用HTTP的GET或POST方法将日志消息上传到一台HTTP 服务器。 
logging.handlers.RotatingFileHandler(filename) 将日志消息写入文件filename。如果文件的大小超出maxBytes制定的值，那么它将被备份为filenamel。 
logging.handlers.SocketHandler 使用TCP协议，将日志信息发送到网络。 
logging.handlers.SysLogHandler 日志输出到syslog 
logging.handlers.NTEventLogHandler 远程输出日志到Windows NT/2000/XP的事件日志 
logging.handlers.SMTPHandler 远程输出日志到邮件地址 
logging.handlers.MemoryHandler 日志输出到内存中的制定buffer 
```

