---
title: Vue1
layout: post
tags: 前端
categories: ''
---

## 一、认识vue

​		vue是一个渐进式的矿建，，渐进式意味着可以**将vue作为你应用的一部分嵌入其中**，带来丰富的交互体验。

### vue特点

1. 解耦视图和数据
2. 可复用的组件
3. 前端路由技术
4. 状态管理
5. 虚拟DOM

## 二、安装

1. 直接cdn引入

   开发环境和生产环境两个版本

   ```
   <!-- 开发环境版本，包含了有帮助的命令行警告 -->
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   ```

   或者：

   ```
   <!-- 生产环境版本，优化了尺寸和速度 -->
   <script src="https://cdn.jsdelivr.net/npm/vue"></script>
   ```

2. 下载s和引入

3. npm安装

   后续通过webpack和CLI进行安装

## 三、MVVM结构

**view层**

​	视图层，在前端中，通常就是DOM层，主要用于给客户展示各种信息

**model层**

​	数据层，数据可能是我们固定的死数据，更多的是来自我们服务器，从网络请求的数据

**ViewModel层**

​	视图模型层，是model和view沟通的桥梁；

​	一方面实现Data Binding，即数据绑定，将model的改变实时的反应到view中；

​	另一方面她实现DOM Listener，也就是DOM监听，当DOM发生一些事件[点击、滚动、touch等]时，可以监听到，并在需要的情况下改变对应的Data

## 四、生命周期

## 五、计算属性和methods属性

conputed 可以节省计算次数，推荐使用computed计算属性； methods计算次数较多。

## 六、let 和 var

```
var 的设计可以看成是JavaScript语言设计上的错误，但是这种错误多半是不能修复和移出，以后需要向后兼容

后来，JavaScript作者Brendan Eich就决定修复这个问题，于是他增加了一个新的关键字：let

我们可以将let看成更加完美的var。
```

### 块级作用域

var没有块级作用域，let有块级作用域

## 七、const的使用

在很多语言中已经存在，比如C、C++中，主要的作用是将某个变量修饰为常量；

1. 在JavaScript中也是如此，使用const修饰的标识符不能被二次赋值
2. 在定义的时候必须赋值
3. 常量的含义是指向的对象不能修改，但是可以修改对象内部的属性

## 八、v-on的参数

1. 事件定义的时候，写方法时省略了小括号，但是方法本身是需要一个参数的，这个是时候，VUE会默认将浏览器产生的**event事件对象**作为参数传递到方法。

   ```
   @click = 'btn2Click'	
   ```

2. 通过$event 可以获得浏览器产生的event

```
@click = "btn3Click(abc,$event)"
```

3. v-on修饰符

   参考https://blog.csdn.net/sleepwalker_1992/article/details/82903246

```
v-on 事件修饰符
常用的事件修饰符有：

.stop  阻止事件冒泡
.self  当事件在该元素本身触发时才触发事件

.capture 添加事件侦听器是，使用事件捕获模式

.prevent  阻止默认事件

.once 事件只触发一次
```

```
v-on 按键修饰符
Vue 允许为 v-on 在监听键盘事件时添加按键修饰符

按键别名：
    .enter
    .tab
    .delete (捕获 "删除" 和 "退格" 键)
    .esc
    .space
    .up
    .down
    .left
    .right
    .ctrl
    .alt
    .shift
    .meta

注意：在Windows系统键盘上meta对应windows徽标键(⊞)。
```

## 九、filter，map，reduce

这几个函数的用法与python中的相同

```javascript
const nums = [10,20,111,222,444,40,50]
let total = nums.filter(n => n<100).map(n=> n*2).reduce((pre,n)=>pre+n)
console.log(total)
```

## 十、 v-model双向绑定

1. v-bind绑定一个value属性
2. v-on指令给当前的元素绑定input事件

```html
<input type = 'text' v-model='message'>
等同于
<input type = 'text' v-bind:value = 'message' v-on:input="message = $event.target.value"
```

修饰符

```vue
v-model.lazy  让数据失去焦点时或者敲回车，才实现绑定

v-model.number 将字符串转化为数字

v-model.trim  去除输入的空格
```

## 十一、组件化

### 1. 组件化模块化开发

开发步骤：

1. 创建组件构造器

   vue.extend() : 调用Vue.extend()创建的是一个组件构造器；

   通常在创建组件构造器时，传入template代表我们自定义组件的模板；

   该模板就是使用到组件的地方，要显示的HTML代码

   现在基本不用这个写法了，直接使用下面的Vue.component()创建

   

2. 注册组件

   ```html
   <template id="cpn">
   			<!-- 注意，这个地方需要用div包起来 -->
   			<div>
   				<h2>
   					当前计数为{{counter}}
   				</h2>
   				<button type="button" @click="decrement"> - </button>
   				<button type="button" @click="increment"> + </button>
   			</div>
   </template>
   <script>
   		Vue.component('cpn', {
   			template: "#cpn",
   			data() {
   				return {
   					counter: 0
   				}
   			},
   			methods: {
   				increment() {
   					this.counter++
   				},
   				decrement() {
   					this.counter--
   				}
   			}
   		})
   
   		const app = new Vue({
   			el: '#app',
   		})
   	</script>
   ```

   vue.component()

   用来注册组件，需要传入两个参数：1.注册组件的标签名 2. 组件构造器

   注意：组件创建时，data为函数，防止复用时候的干扰

3. 使用组件

### 2. 父子通信

​	父传子 props

​	字传父 $emit 

​		$emit('事件名'，变量值)

![image-20210416140056934](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210416140056934.png)

## 十二、插槽 slot

在组件中定义slot，后面可以直接写入替换，实现组件复用，提升扩展性能

### 1. 匿名插槽

替换掉整个slot单元

### 2. 具名插槽

通过name属性进行命名

```js
// 组件
Vue.component('lv-hello', {
  template: `
    <div>
      <slot name="header"></slot>
      <h1>我的天呀</h1>
    </div>
  `
})
```

```html
<div id="app">
  <!-- 老版本使用具名插槽 -->
  <lv-hello>
    <p slot="header">我是头部</p>
  </lv-hello>
  <!-- 新版本使用具名插槽 -->
  <lv-hello>
    <!-- 注意：这块的 v-slot 指令只能写在 template 标签上面，而不能放置到 p 标签上 -->
    <template v-slot:header>
      <p>我是头部</p>
    </template>
  </lv-hello>
</div>
```

> 将 `v-slot:` 替换成 `#` 号

```html
<div id="app">
  <lv-hello>
    <template #header>
      <p>我是头部</p>
    </template>
    <!-- 注意: #号后面必须有参数，否则会报错。即便是默认插槽，也需要写成 #default -->
    <template #default>
      <p>我是默认插槽</p>
    </template>
  </lv-hello>
</div>
```

### 3. slot 和slot-scope

vue3中使用v-slot代替slot-scope

## 十三、模块化

通用的前端模块化规范：

1. commonJS模块化

   依赖环境，导入  导出

   export ， require

   ```javascript
   require('../aaa.css')
   ```

   

2. ES6模块化

   export（导出） import（导入）

   * 首先在js文件中加入type = module

     ````html
     <script src="aaa.js" type = "module"></script>
     <script src="bbb.js" type = "module"></script>
     ````

   * 在aaa.js中写好导出

     ```javascript
     export {flag,sum};	
     export let a = 100;
     export function test(){}
     export class Person{}
     //default后面的数量只有一个，同一个js文文件只有一个export default
     export default address 
     ```

   * 在bbb.js中导入就行了

     ```javascript
     import {flag ,sum} from 'aaa.js';
     import {a} from 'aaa.js';
     import * as aaa from 'aaa.js'
     ```

     

## 十四、webpack工具详解

​	webpack是一个现代的JavaScript应用的静态**模块**、**打包**工具

### 1. 前端模块化：

- ​	在ES6之前，我们要进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发
- 并且通过模块化开发完成了项目后，还需要处理模块见的各种依赖，并且将其进行**整合打包**
- ​	webpack其中一个核心就是让我们可能进行**模块化开发**，并且会**帮助我们处理模块间的依赖关系**。
- webpack不仅仅是JavaScript文件，相关的css、图片、json文件等等在webpack中都可以被当做模块来使用

1. 安装node

2. 安装webpack

   ```
   npm install webpack@3.6.0 -g
   ```

3. 建两个文件夹 src ，dist

   在src文件夹中开发，使用webpack打包到dist文件夹中

   ```
   webpack ./src/aaa.js ./dist/buddle.js
   ```

​	4. 后面直接引用dist中的buddle.js就可以了

### 2.webpackde配置文件

​	通过webpack配置文件，可以定义导出和导入，自动化一键导出，这个文件就是webpack.config.js

entry - 入口

output - 出口，这个后面的路径必须为绝对路径，写成path是为了通过node写绝对路径。通过命令 

```
npm init	
```

生成package.json.

```javascript
{
	'name':'meetwebpack',
    'version':'1.0.0',
    'description'：'',
     'main':'index.js'
    'script':{
	'test':'echo\"no test specified"&&exit 1',
     'build':'webpack'
    },
    'author':'',
     'license':'ISC'
    'devDependencies':{
        'webpack':"^3.6.0"
    }
}
```

package.json中定义了webpack与npm的映射，后面只需要执行npm run build 相当于执行 上面json文件中build后面的内容;

devDependencies 为开发式依赖，这个配置在 npm install webpack@3.6.0 --save-dev 自动生成

下面在webpack.config.js中定义出口入口

```javascript
const path = require('path')
module.exports = {
	entry:'./src/main.js',
	output:{
    	path:path.resolve(__dirname,'dist'),
    	filename:"buddle.js"
	}
}
```

可以知道，需要导出一个path的包，用来做路径； 这个地方运行下

```
npm install 
```

就可以添加依赖项，即path包了

main.js文件中，写明引用src中的 buddle.js 就行了



参考：https://webpack.docschina.org/concepts/

### 3.css文件处理

此时需要对webpack进行扩展，安装

```
npm install --save-dev css-loader
npm install --save-dev style-loader
```

在webpack.config.js中写明

```javascript
const path = require('path')
module.exports = {
	entry:'./src/main.js'
	output:{
    	path:path.resolve(__dirname,'dist')
    	filename:'buddle.js'
	},
  	module:{
        rules:[
            {	// 使用正则表达式匹配css文件
                test:'/\.css$/',
                // style-loader负责养殖添加到DOM中
                // css-loader只负责对css文件进行加载
                use:['style-loader','css-loader']
            }
        ]
    }
}

```



### 4.less文件处理

需要安装loader

```
npm install --save-dev less-loader less
```

### 5.图片处理

```
npm install --save-dev file-loader
npm install --save-dev url-loader
```

webpack会打包图片，其中图片名字会被hash成新名字，并放入dist文件夹中



### 6.es6转es5

```
npm install -D babel-loader @babel/core @babel/preset-env webpack
```

### 7.理解vue的组件化开发

https://www.bilibili.com/video/BV1H7411j7Mc?p=84&spm_id_from=pageDriver

### 8.html-webpack-plugin插件

**webpack.config.js**

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 访问内置的插件
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader',
      },
    ],
  },
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({ template: './src/index.html' }),
  ],
};
```

`ProgressPlugin` 用于自定义编译过程中的进度报告，`HtmlWebpackPlugin` 将生成一个 HTML 文件，并在其中使用 `script` 引入一个名为 `my-first-webpack.bundle.js` 的 JS 文件。

### 9. uglifyjs-webpack-plugin插件

丑化代码，用于压缩代码大小

**webpack.config.js**

```js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [new UglifyJsPlugin()],
  },
};
```

紧接着通过你的首选方式运行 `webpack`。

### 10.开发服务器(`devServer`) 

通过 [webpack-dev-server](https://github.com/webpack/webpack-dev-server) 的这些配置，能够以多种方式改变其行为。这是一个简单的示例，利用 `gzips` 压缩 `dist/` 目录当中的所有内容并提供一个本地服务(serve)：

**webpack.config.js**

```javascript
var path = require('path');

module.exports = {
  //...
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000,
  },
};
```

当服务(`server`)启动后，在解析模块列表之前输出一条消息：

```bash
http://localhost:9000/
webpack output is served from /build/
Content not from webpack is served from /path/to/dist/
```

这里将会给出服务启动位置以及内容的一些基本信息。

如果你通过 Node.js API 使用 dev-server，则 `devServer` 中的配置选项将被忽略。但可以将配置选项作为第二个参数传入：`new WebpackDevServer(compiler，{...})`。[此示例](https://github.com/webpack/webpack-dev-server/tree/master/examples/api/simple)展示了如何通过 Node.js API 使用 webpack-dev-server。

### 11.配置文件分离

首先建立build文件夹，用来存放分离后的的文件，开发配置文件、生产配置文件、基本配置文件

```
-- build
	|-- base.config.js
	|-- dev.config.js
	|-- prod.config.js
-- dist
-- src
-- package.json
```

第二步需要安装合并组件

````
npm install webpack-merge --save-dev
````

base.config.js

```javascript
module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
   module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader',
      },
    ],
  }
}
```

prod.config.js

```javascript
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const webpackMerge = require('webpack-merge')
const baseConfig =require('./base.config.js')
module.exports = webpackMerge(baseConfig ,{
	plugins:[
	new UglifyJsPlugin()
	]
})
```

dev.config.js

```javascript
const webpackMerge = require('webpack-merge')
const baseConfig =require('./base.config.js')
module.exports =webpackMerge(baseConfig , {
	devServer:{
		contentBase:'./dist',
		inline:true
	}
})
```

合并基础配置base.config.js和prod.config.js内容，后输出

此时没有了webpack.config,js 文件，而是分解到了build文件夹下的三个文件，所以在编译的时候需要修改package.json文件：

* 修改build的路径
* 修改dev路径
* 返回去修改base.config.js中的路径，将./dist 修改为 ../dist，这样，重新打包生成的文件就在原来的dist文件夹下

package.json

```json
{
	'name':'meetwebpack',
    'version':'1.0.0',
    'description'：'',
     'main':'index.js'
    'script':{
	'test':'echo\"no test specified"&&exit 1',
     'build':'webpack --config ./build/prod.config.js'
     'dev':'webpack-dev-server  --open --config ./build/dev.config.js'
    },
    'author':'',
     'license':'ISC'
    'devDependencies':{
        'webpack':"^3.6.0"
    }
}
```

此时运行

```
// 执行打包
npm run build
npm run dev
```



## 十五、Vue CLI

### 1.脚手架 CLI

​	CLI -- Command-Line Interface，命令行界面，俗称脚手架

​	Vue CLI 是官方发布的vue.js项目脚手架

​	使用脚手架可以快速搭建Vue开发环境一级对应的webpack配置

### 2.使用前提 

​	Node、webpack

安装淘宝的cnpm

```shell
# 第一步
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

### 3.安装

```sh
# 第二步
# 使用这个命令 //使用这个命令可以实现cnpm代替npm安装cli
npm install -g vue-cli
//下面这个用于cli3
npm install -g f@vue/cli
```

Vue CLI2初始化项目

```
vue init webpackage my-project
```

Vue CLI3初始化项目

```shell
# 第三步
vue create my-project
```



### 4.runtime-only和runtime-compiler

runtim-compiler需要的过程 ：  template --> ast(抽象语法树)-> render --> vdom(虚拟dom)-->UI

runtime-only 过程：render-> vdom -> UI

所以runtime-only更加快一些，choose it

https://www.bilibili.com/video/BV1H7411j7Mc?p=95&spm_id_from=pageDriver



### 5.vue-cli3

- vue-cli3 是基于webpack 4 打造， vue-cli 2 是基于webpack3打造
- vue-cli3的设计原则是 ‘0’配置，移除了配置文件根目录下的 build和config等目录
- vue-cli3 提供了vue ui命令，提供了可视化配置，更加人性化
- 移除了static文件夹，新增了public文件夹，并且index.html移动到了public中

## 十六、箭头函数

ES6标准新增了一种新的函数：Arrow Function（箭头函数）。

为什么叫Arrow Function？因为它的定义用的就是一个箭头：

```
x => x * x
```

上面的箭头函数相当于：

```
function (x) {
    return x * x;
}
```

### 1.基本用法

```javascript

var fn1 = function(a, b) {
    return a + b
}
 
function fn2(a, b) {
    return a + b
}
```

使用ES6箭头函数语法定义函数，将原函数的“function”关键字和函数名都删掉，并使用“=>”连接参数列表和函数体。

```javascript
var fn1 = (a, b) => {
    return a + b
}

(a, b) => {
    return a + b
}
```


当函数参数只有一个，括号可以省略；但是没有参数时，括号不可以省略。

```javascript
// 无参
var fn1 = function() {}
var fn1 = () => {}

// 单个参数
var fn2 = function(a) {}
var fn2 = a => {}

// 多个参数
var fn3 = function(a, b) {}
var fn3 = (a, b) => {}

// 可变参数
var fn4 = function(a, b, ...args) {}
var fn4 = (a, b, ...args) => {}
```

箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，省略掉了{ ... }和return。还有一种可以包含多条语句，这时候就不能省略{ ... }和return

```javascript
() => return 'hello'
(a, b) => a + b
(a) => {
  a = a + 1
  return a
}
```




### 2.箭头函数的作用域  this

传统的非箭头函数

![img](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\71)

**现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者Person**

![img](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\70)

## 十七、路由

### 1.认识路由

路由是网络工程中的术语，就是通过互联网的把信息从源地址传输到目的地址的活动

路由器提供两种机制：

* 路由：路由是决定数据包从**来源**到**目的地**的路径
* 传送：转送将**输入端**的数据转移到合适的**输出端**

路由中有一个非常重要的概念就是路由表，路由表的本质就是一个映射表，决定了数据包的指向

### 2.前端渲染和后端渲染

#### 1.后端渲染

早期使用的jsp（java server page），包括html+css+java。java代码的作用是从数据库中读取数据，并且将他动态的放在页面中。这种在服务端渲染返回给客户端的方式称为后端渲染。

**缺点： **

* 整个页面的模块都需要后端来编写和维护
* 前端页面需要维护必须学会后端的语言，如php，java
* html代码和数据交织在一起，编写和维护都很糟糕

#### 2.前后端分离

随着ajax的出现，出现了前后端分离的开发模式。

后端只负责提供数据或者api，不负责任何阶段的内容。前端通过ajax获取数据，此时浏览器中显示的网页大部分内容都是有html + css和JavaScript在浏览器中执行，最终生成的页面。

**优点：**

* 后端职责清洗，专注于数据；前端专注于交互和可视化。
* 当移动端（iOS/Android)出现后，后端不需要做任何处理，依然使用之前的一套API即可。

#### 3.单页面富应用阶段（SPA页面）

整个网页只有一个页面 ;SPA最主要的特点就是在前后端分离的基础上加了一层前端路由，也就是前端来维护一套路由规则。

前端路由的核心是：改变URL，但是整体页面不刷新，不向服务器请求资源

### 3.vue-router

目前前端流行的三大框架，都有自己的路由实现：

* Angluar 的 ngRouter
* React 的 ReactRouter
* Vue 的 Vue-router

vue-router是Vue.js官方路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。

#### 1.安装

```shell
npm install vue-router --save
```

#### 2.配置与应用

在router/index.js中定义router对象并导出，在这个地方导入Home 和About组件 【见下面的导出】，并设定路由链接，导出路由

```javascript
import VueRouter from 'vue-router'
import Vue from 'vue'
import Home from '../conponents/Home'
import About from '../conponents/About'
// 1. 通过Vue.use（插件），安装插件
Vue.use(VueRouter)
const routers = [
    // 设置路由默认值,默认显示主页
    {
        path:"/",
        redirect:"/home"
    },
    {
        path:'/home',
    	component:Home
    },
    {
        path:'/About',
        component:About
    }
}]
// 2.创建VueRouter对象
const router = new VueRouter({
    routers,
    // 使用html的history模式，此时就没有路径中的#号
    mode:'history'
})
// 3.将router对象传入到实例,导出
export default router
```

在main.js中引用，引用上面导出的路由

```javascript
import Vue from 'Vue'
import APP from './App'
import router from './router'

new Vue({
    el:'#app',
    router,
    render:h =>h(App)
})
```

在component文件夹中创建home.vue，about.vue

home.vue ，以Home模块导出

```html
<tempalte>
	<div>
		<h2>
            我是首页，AAA
        </h2>    
 	</div>
</tempalte>	
<script>
    export default {
        name:'Home'
    }
</script>
```

about.vue， 以About模块导出

```html
<tempalte>
	<div>
		<h2>
            我是首页，AAA
        </h2>    
 	</div>
</tempalte>
<script>
    export default {
        name:'About'
    }
</script>
```

在app.vue中，通过main.js进行代码支撑

```html
<template>
    <div id="app">
        <router-link to='/home'>首页</router-link>
        <router-link to='/about'>关于</router-link>
        <router-view></router-view>
    </div>
</template>

<script>
	export default{
        el:'#app'
    }
</script>

```

补充： 

* router-link中的to属性，用于指定跳转的路径
* tag属性，用于指定经过\<router-link>渲染后的组件，如tag="button",设定为按钮；默认值是tag=‘a’
* replace： repalce不会留下history记录，使用replace属性，浏览器的后退键不能返回上一个页面
* active-class：当\<router-link>对应的路由匹配成功后，会自动给当前元素设置一个router-link-active的class，设置active-class可以默认修改的名称；如，根据active激活状态控制按钮变成红色。

































































































