---
title: docker命令
layout: post
tags: docker
categories: ''
---

# Docker 狂神课程

#### Ubuntu docker

```shell
# 1.卸载原来老版本的docker
sudo apt-get remove docker docker-engine docker.io containerd runc
# 2.下载docker
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun

# 2.安装
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io

```

#### Ubuntu安装 docker-compose

```shell
sudo apt-get install docker-compose
```

#### 帮助命令

```shell
docker version # 显示版本信息
docker info    # 显示docker系统信息，包括镜像数量、容器数量
```

#### 镜像命令

**docker images** 

```shell
zhengkan03@ubuntu:~/桌面$ docker images
REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
<none>                    <none>    fa7b17d27d4a   3 months ago    2.74GB
windspeed                 latest    ed0455db2d73   3 months ago    2.22GB

# 解释
REPOSITORY   镜像的仓库源
TAG			镜像的标签
IMAGE ID   	镜像ID
CREATED    	镜像的创建时间
SIZE      	镜像的大小
```

***

**docker search** 搜索镜像

```shell
(base) zhengkan03@ubuntu:~/桌面$ docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   11023     [OK]       
mariadb   MariaDB Server is a high performing open sou…   4177      [OK]  

# 解释
可选项 --filter=STARS=3000 搜索星星大于3000的镜像
```

**docker pull**下载镜像

```shell
# 下载最新版本
(base) zhengkan03@ubuntu:~/桌面$ docker pull mysql
Using default tag: latest
latest: Pulling from library/mysql
69692152171a: Pull complete       # 分层下载
1651b0be3df3: Pull complete 
951da7386bc8: Pull complete 
0f86c95aa242: Pull complete 
37ba2d8bd4fe: Pull complete 
6d278bb05e94: Pull complete 
497efbd93a3e: Pull complete 
f7fddf10c2c2: Pull complete 
16415d159dfb: Pull complete 
0e530ffc6b73: Pull complete 
b0a4a1a77178: Pull complete 
cd90f92aa9ef: Pull complete 
Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest

# 等价
# docker pull mysql 
# docker pull docker.io/library/mysql:latest

# 下载指定版本
# docker pull 镜像名[:版本号]
# docker pull mysql:5.7
```

**docker rmi 镜像名** 删除镜像

```shell
# docker rmi 镜像名
docker rmi 镜像id
docker rmi -f 镜像id 					# 强制删除镜像
docker rmi -f $(docker ps -aq)         # 删除所有镜像
```

#### 容器命令

**docker run [可选参数] **

```shell
docker run [可选参数] image

# 参数说明
--name="Name"   指定运行镜像后的容器名字 tomcat01 
-d 			   后台方式运行
-it			   使用交互方式，进入容器内部
-p			  指定容器端口 -p 8000::8080
	-p ip:主机端口:容器端口
	-p 主机端口:容器端口 （常用）
	-p 容器端口:容器端口
-P 			   随机指定端口
# 运行并进入容器
 zhengkan03@ubuntu:~/桌面$ docker run -it centos /bin/bash
```

**docker ps** 列出容器

```shell
docker ps
	# 列出当前正在运行的容器
-a  # 列出所有容器【历史的容器+正在运行的容器】
-q  # 只显示容器编号

```

**退出容器**

```shell
exit  # 直接容器停止并退出
CTRL + P + Q # 容器不停止，退出
```

**删除容器**

```shell
docker rm 容器id					# 删除指定容器 ，不能删除正在运行的容器
docker rm -f $(docker ps -aq)	   # 删除所有容器
```

**启动容器和停止容器**

```shell
docker start 容器id
docker restart 容器id
docker stop 容器id
docker kill 容器id  # 强制停止当前容器
```

```常用的命令

​```shell
# 查看日志
docker logs 
docker logs -tf -tail n 容器id   # 查看最后n条日志  -t 显示时间戳   -f 跟随时间戳

# 示例
zhengkan03@ubuntu:~/桌面$ docker logs -tf --tail 10 26b6aea91aaa
2021-06-22T07:48:50.905093443Z 
2021-06-22T07:48:50.905095407Z To try something more ambitious, you can run an Ubuntu container with:
2021-06-22T07:48:50.905097543Z  $ docker run -it ubuntu bash
2021-06-22T07:48:50.905099590Z 
2021-06-22T07:48:50.905101646Z Share images, automate workflows, and more with a free Docker ID:
2021-06-22T07:48:50.905103754Z  https://hub.docker.com/
2021-06-22T07:48:50.905105835Z 
2021-06-22T07:48:50.905107823Z For more examples and ideas, visit:
2021-06-22T07:48:50.905109929Z  https://docs.docker.com/get-started/
2021-06-22T07:48:50.905112002Z 
```

```shell
# 查看进程信息
docker top 容器id

# 示例
hengkan03@ubuntu:~/桌面$ docker top ffbdccd23b40
UID                 PID                 PPID                C                   STIME               TTY             
root                4003                3981                1                   16:02               ?               
root                4048                4003                2                   16:02               ?               
```

```shell
# 查看容器元数据
docker inspect 容器id
# 示例
zhengkan03@ubuntu:~/桌面$ docker inspect ffbdccd23b40
[
    {
        "Id": "ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496",
        "Created": "2021-06-22T08:02:15.072353163Z",
        "Path": "python3",
        "Args": [
            "WindPlatform.py"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 4003,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2021-06-22T08:02:15.329542854Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:fa7b17d27d4a5dffbfef573effc6c11f8e08050df1d5479d58196a9d3e57e3e4",
        "ResolvConfPath": "/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/hostname",
        "HostsPath": "/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/hosts",
        "LogPath": "/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496-json.log",
        "Name": "/nifty_euclid",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "docker-default",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d-init/diff:/var/lib/docker/overlay2/17a7729fae872dc47beaddd86c02f5a95d1c8b17525e49e9457ff52e126dfc17/diff:/var/lib/docker/overlay2/fa10d11839ed464f0bd78ba5d9cb8fef8212e391876569631c0c04a59aa6e3e3/diff:/var/lib/docker/overlay2/b3c96094f9204af39890d1b8101278a98d7cc6c9c96e76c8fa2efb19d6181a0b/diff:/var/lib/docker/overlay2/c8fe8f5fd4e56531f6452da6ad5e8d300f2b48042a0c72a18fe4e11b3a369aec/diff:/var/lib/docker/overlay2/d28d47c24554c918e4814ef21087b7b334d6b02055c22a690714d9fe905d2407/diff:/var/lib/docker/overlay2/7343c35e91fb791e62ec43253c0ae1705b54dbe72ab65b1361e3a33f7bea1610/diff:/var/lib/docker/overlay2/1ff46c566494d2451a35636d7b28461d0ea2f2c2dd2af2920de52ee25ba53529/diff:/var/lib/docker/overlay2/e736e69f6bb2b87efb5ff8d693c4fd37d887502a06a5b9fabff96ad8153c7f9c/diff:/var/lib/docker/overlay2/18a19eee18a38481e0db17be63f675b6edddba3c72f6ec3ea99b2446b44198c8/diff:/var/lib/docker/overlay2/1cab6ed396a099774fbf46013adbb04aae80e173af01b08bbaebd4330ee5417e/diff:/var/lib/docker/overlay2/0a990a330b637a03878dece926106670d67a6848220433163e8b614e26a4d5fe/diff:/var/lib/docker/overlay2/dcb2bdf25e93fc854e9f20db7af8a15d8121591d0fdc4adf6fd3897c6ad42794/diff:/var/lib/docker/overlay2/32ff4d2f742d16b700a2e71d3e6c4508a976046869a472e52fb7057e2bab2f6c/diff:/var/lib/docker/overlay2/09f6a5b7a03f34cd7ddd7fab9ba8fe9aa3ddf9e232fabf3c54fc8602d80a2f1f/diff",
                "MergedDir": "/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/merged",
                "UpperDir": "/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/diff",
                "WorkDir": "/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [
            {
                "Type": "volume",
                "Name": "506ba62d402f692daf45dad5a846cff4e553a710f541e78949466e0e92325ea9",
                "Source": "/var/lib/docker/volumes/506ba62d402f692daf45dad5a846cff4e553a710f541e78949466e0e92325ea9/_data",
                "Destination": "/sys/fs/cgroup",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
        "Config": {
            "Hostname": "ffbdccd23b40",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "container=docker",
                "DEBIAN_FRONTEND=noninteractive",
                "LANG=en_US.UTF-8",
                "LANGUAGE=en_US:en",
                "LC_ALL=en_US.UTF-8"
            ],
            "Cmd": [
                "python3",
                "WindPlatform.py"
            ],
            "Image": "fa7b17d27d4a",
            "Volumes": {
                "/sys/fs/cgroup": {}
            },
            "WorkingDir": "/app",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "5f09b2026536f58852715967f0f1487828195533aa71896838e9074634e2a403",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/5f09b2026536",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "d88f24d5ea6a94c7a9ee0359d7bd829cf66e4dc70ebe7d827b709a8c0a836dd2",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "8f3b1769f0151de1a0edac3bf15a02e0828f2ea16919098ec4cdfd43f0f90ad4",
                    "EndpointID": "d88f24d5ea6a94c7a9ee0359d7bd829cf66e4dc70ebe7d827b709a8c0a836dd2",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]

```

```shell
# 进入容器
docker exec -it 容器id /bin/bash

# 示例
zhengkan03@ubuntu:~/桌面$ docker exec -it  ffbdccd23b40 /bin/bash
root@ffbdccd23b40:/app# ls
data  Dockerfile  LSTM.py  __pycache__  README.md  requirements.txt  static  templates  WindPlatform.py

# 进入容器
docker attach

# 区别
docker exec       # 进入容器后开启一个新的终端
docker attach	  # 进入容器正在执行的终端，不会启动新的进程
```

```shell
# 容器内文件拷贝到主机 	
docker cp 容器id:路径 宿主机路径
# 示例
zhengkan03@ubuntu:~/桌面$ docker cp ffbdccd23b40:/app/ /home/zhengkan03/Desktop/
```

#### 作业 部署nginx

```sh
# 启动容器
zhengkan03@ubuntu:~/桌面$ docker run -d -p 3344:80 nginx       # 3344为本地端口，80为容器nginx的端口

# 访问nginx
zhengkan03@ubuntu:~/桌面$ curl localhost:3344
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>

```

**commit镜像**

```shell
# 将容器打包为镜像
docker commit -m="提交的内容说明" -a="作者" 容器id 目标镜像名:版本号（tag）
```

#### 容器数据卷

docker的理念： 将应用和环境打包为一个镜像！

数据，如果保存在容器中，那么容器被删除，数据就会丢失。 **需求** 数据的持久化

MySQL 容器删了，删库跑路！ **需求** MySQL数据需要存储到本地

**总结一句话：容器的持久化和同步话操作！ 容器间可以数据共享**

##### 1.使用数据卷

>方式一：直接使用-v数据挂载;  功能是实现双向绑定
>
>容器内部添加文件，可同步到主机
>
>主机指定文件夹下添加文件可同步到容器内

```shell
docker run -it -v 主机目录:容器内目录

# 启动后可以通过docker inspect 容器id 查看挂载->Mount
```

##### 2.实战：安装mysql

```shell
# 获取镜像
zhengkan03@ubuntu:~$ docker pull mysql:5.7
# 运行容器，需要做数据挂载，安装启动mysql，需要配置密码，这是注意点！
# 官方测试 docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

zhengkan03@ubuntu:~$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7

# 运行成功，启动测试
```

<img src=".\images\image-20210622194742910.png" alt="image-20210622194742910" style="zoom:50%;" />

连接成功，没有问题！

此时，如果删除容器，也不会删除本地文件，从而实现文件的持久化！

##### 3.具名挂载和匿名挂载

```sh
# 匿名挂载
docker run -d -P --name nginx01 -v /etc/nginx nginx
-v 容器内路径  # 匿名挂载，不建议使用
-v 卷名:容器内路径  # 具名挂载
-v /宿主机路径:容器内路径  # 指定路径挂载

# 通过 -v 容器内路径：ro rw 改变读写权限  ，设置后只能通过宿主机操作，不能容器内操作
ro  readonly    # 只读
rw  readwrite   # 可读可写
docker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx:/etc/nginx:ro nginx
docker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx:/etc/nginx:rw nginx
```

那么，匿名挂载的路径在哪里呢？

```shell
zhengkan03@ubuntu:~$ docker inspect nginx01
"Mounts": [
            {
                "Type": "volume",
                "Name": "38b836d04cf18329a23481d13abbf5bd29d5f79c81981edaf2b776d6254e47aa",
                "Source": 			"/var/lib/docker/volumes/38b836d04cf18329a23481d13abbf5bd29d5f79c81981edaf2b776d6254e47aa/_data",
                "Destination": "/etc/nginx",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
```

可以看出，匿名挂载到了 */var/lib/docker/volumes/* 下。

##### 4.初始Dockerfile

```dockerfile
FROM centos
VOLUME ['volume1','volume2']  # 这个地方进行匿名挂载
CMD echo "--end--"
CMD /bin/bash
```

匿名挂载挂载的地方是 /var/lib/docker/volumes/ 下。可以通过docker inspect 容器名 查看

如果没有dockerfile编写时没有挂载数据卷，那么可以通过  docker run 镜像名 -v 卷名:容器内路径挂载！

#### DockerFile

##### 1.dockerfile介绍

dockerfile是用来构建镜像文件！ 命令参数脚本！

构建步骤：

1. 编写一个dockerfile文件
2. docker build 构建成为一个镜像
3. docker run 运行镜像
4. docker push 发布镜像（dockerHub,阿里云）

##### 2.dockerfile构建

**基础知识**

1. 每个保留关键字（指令）必须是大写字母
2. 执行从上到下
3. #表示注释
4. 每个指令都会创建提交一个新的镜像层

dockerfile是面向开发的，以后我们要发布项目、做镜像，就需要编写dockerfile文件，这个文件十分简单！

Docker镜像逐渐成为企业交付的标准,必须要掌握！

步骤：

1. DockerFile:构建文件，定义一切的步骤、源代码

2. DockerImages：通过Dockerfile构建生成的镜像，最终发布和运行产品

3. Docker容器：容器就是镜像运行起来提供服务器

##### 3.dockerfile的指令

```shell
FROM   		# 基础镜像，一切从这里开始
MAINTIANER 	# 镜像是谁编写的，姓名+邮箱
RUN     	# 镜像构建时候需要运行的命令
ADD			# 步骤，tomcat镜像，添加内容
WORKDIR 	# 镜像的工作目录
VOLUME		# 挂载的目录
EXPOSE		# 暴露对外端口
CMD			# 指定这个容器的启动时候的命令 ,只有最后一个会生效
ENTRYPOINT	# 指定 容器启动时候要运行的命令，可以追加命令
ONBUILD		# 当构建一个被继承Dockerfile，这个时候就会运行ONBUILD
COPY		# 类似ADD	,将文件拷贝到镜像中
ENV			# 构建的时候设置环境变量

```

##### 4. 实战测试

**创建自己的centos**

```shell
# 1. 编写Dcokerfile文件
FROM centos
MAINTAINER zhengkan<zhengkan1993@gmail.com>

ENV MYPATH /usr/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD /bin/bash
# 2. 通过这个文件创建镜像
#命令 docker build -f dockerfile文件路径 -t 镜像名:版本号
docker build -f Dockerfile mycentos:1.0
# 3.测试运行
docker run -it mycentos：1.0
# 可以使用docker inspect 镜像名 来查看镜像构建历史
```

**CMD和ENTRYPOINT区别**

测试CMD

```shell
FROM centos
CMD["ls",'-a']
```

运行后，ls -a生效

```
zhengkan03@ubuntu:~/docker学习$ docker run 358cddd4cadf
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
```

测试ENTRYPOINT

```dockerfile
FROM centos
ENTRYPOINT["ls","-a"]
```

为了执行 ls -al，可以直接在运行进行是添加

```shell
zhengkan03@ubuntu:~/docker学习$ docker run 4fb5907fbf3a -l
total 56
drwxr-xr-x   1 root root 4096 Jun 28 16:22 .
drwxr-xr-x   1 root root 4096 Jun 28 16:22 ..
-rwxr-xr-x   1 root root    0 Jun 28 16:22 .dockerenv
lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -> usr/bin
drwxr-xr-x   5 root root  340 Jun 28 16:22 dev
drwxr-xr-x   1 root root 4096 Jun 28 16:22 etc
drwxr-xr-x   2 root root 4096 Nov  3  2020 home
lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -> usr/lib64
drwx------   2 root root 4096 Dec  4  2020 lost+found
drwxr-xr-x   2 root root 4096 Nov  3  2020 media
drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt
drwxr-xr-x   2 root root 4096 Nov  3  2020 opt
dr-xr-xr-x 371 root root    0 Jun 28 16:22 proc
dr-xr-x---   2 root root 4096 Dec  4  2020 root
drwxr-xr-x  11 root root 4096 Dec  4  2020 run
lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Nov  3  2020 srv
dr-xr-xr-x  13 root root    0 Jun 28 16:22 sys
drwxrwxrwt   7 root root 4096 Dec  4  2020 tmp
drwxr-xr-x  12 root root 4096 Dec  4  2020 usr
drwxr-xr-x  20 root root 4096 Dec  4  2020 var
```

##### 5. 练习

此处需要基于flask的项目挂载

##### 6.发布自己的镜像到dockerhub

1. 地址https://hub.docker.com/注册自己的账号
2. 确定这个账号可以登录
3. 在我们的服务器上提交自己的镜像
4. 登录完毕即可提交镜像

```shell
zhengkan03@ubuntu:~/桌面$ docker login -u zhengkan
Password: 
WARNING! Your password will be stored unencrypted in /home/zhengkan03/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded

```

```shell
zhengkan03@ubuntu:~/桌面$ docker push zhengkan/hello-world
Using default tag: latest
The push refers to repository [docker.io/zhengkan/hello-world]
An image does not exist locally with the tag: zhengkan/hello-world # 出现镜像不存在的现象
```

```shell
# 使用tag命名
zhengkan03@ubuntu:~/桌面$ docker tag  d1165f221234 zhengkan/hello-world
# push到docker hub
zhengkan03@ubuntu:~/桌面$ docker push zhengkan/hello-world
Using default tag: latest
The push refers to repository [docker.io/zhengkan/hello-world]
f22b99068db9: Mounted from library/hello-world 
latest: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525
```

镜像push时按照层级，一层一层提交。

##### 7.发布自己的镜像到阿里云

1.登录阿里云Docker Registry

```
$ sudo docker login --username=candelazheng registry.cn-hangzhou.aliyuncs.com
```

2. 从Registry中拉取镜像

```
$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/zhengkan/zk_desp:[镜像版本号]
```

3. 将镜像推送到Registry

```shell
$ sudo docker login --username=candelazheng registry.cn-hangzhou.aliyuncs.com
# 这里需要生成一个版本号
$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/zhengkan/zk_desp:[镜像版本号]
$ sudo docker push registry.cn-hangzhou.aliyuncs.com/zhengkan/zk_desp:[镜像版本号]
```

请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。

```shell
zhengkan03@ubuntu:~/桌面$  docker push registry.cn-hangzhou.aliyuncs.com/zhengkan/zk_desp:1.0
The push refers to repository [registry.cn-hangzhou.aliyuncs.com/zhengkan/zk_desp]
f22b99068db9: Pushed 
1.0: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525

```

![Docker Architecture Diagram](..\_posts\images\architecture.svg)

#### Dokcer网络

##### 1.理解网路

![image-20210629110219074](..\_posts\images\image-20210629110219074.png)

原理

我们每次启动一个docker容器，docker就会给docker容器分配一个ip；可以在linux中 ip addr查看

![image-20210629111452787](..\_posts\images\image-20210629111452787.png)

```shell
# 可以看到网卡一对一对的存在，这就是evth-pair技术
# 正是因为这个特性，evth-pair充当一个桥梁，链接各种虚拟网络设备
```

这样，容器和容器之间是可以ping通的。

<img src="..\_posts\images\image-20210629112319783.png" alt="image-20210629112319783" style="zoom:80%;" />

##### 2.小结

<img src="..\_posts\images\image-20210629112837551.png" alt="image-20210629112837551" style="zoom: 80%;" />

docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0。

docker中的所有网络接口都是虚拟的，虚拟的转发效率高！

只要容器删除，对应的网桥一对就没了。

##### 3.容器互联 --link【低配】

>思考一个场景，我们编写了一个微服务，database url =ip，项目不重启，数据库ip换掉了

##### 4.自定义网络【高配】

查看所有的docker网络

![image-20210629115039412](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210629115039412.png)

**网络模式**

1. bridge :桥接  【docker默认】

2. none：不配置网络

3. host：与宿主机共享网络

4. container：容器间网络连通 【用的少】

**测试**

```shell
# 我们直接启动的命令 --net bridge ，而这个就是我们的 docker0
docker run -d -P --name tomcat01 tomcat
docker run -d -P --name tomcat01 --net bridge tomcat

# docker0特点，默认，域名不能访问，--link可以打通连接

# 我们可以自定义一个网络：
# --driver bridge 
# --subnet 192.168.0.0/16
# --gateway 192.168.0.1
zhengkan03@ubuntu:~/桌面$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
zhengkan03@ubuntu:~/桌面$ docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
ecfa71bda54b   bridge    bridge    local
44808524a51d   host      host      local
ea6c93498361   mynet     bridge    local
2deb39155d21   none      null      local

```

![image-20210629120008477](..\_posts\images\image-20210629120008477.png)

```shell
# 在自定义网络下启动两个容器
docker run -d -P --name tomcat-net-01 --net mynet tomcat
docker run -d -P --name tomcat-net-02 --net mynet tomcat
# 查看网络状态，可以看到192.168.0.2的tomcat容器和192.168.0.3的tomcat容器
zhengkan03@ubuntu:~/桌面$ docker inspect mynet 
[
    {
        "Name": "mynet",
        "Id": "ea6c93498361905594f0320ae825995bf71521b4e069ec3aea0dd5f8bc16226e",
        "Created": "2021-06-29T11:59:35.409579492+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.0.0/16",
                    "Gateway": "192.168.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "3e9947a63101af5fa37f46374234a15971a36db16d5a2882b0c47e25cc90f7e5": {
                "Name": "tomcat-net-01",
                "EndpointID": "ae13601d4fcc64e64a6a86c7213a95afb6f283d5560741120b0eaa466f11503f",
                "MacAddress": "02:42:c0:a8:00:02",
                "IPv4Address": "192.168.0.2/16",
                "IPv6Address": ""
            },
            "6ae5b8586fe601001be4c3700304cfa8ab07b07575ee8aa5b0f2ffb23f300df1": {
                "Name": "tomcat-net-02",
                "EndpointID": "3dd3d12308554f3acbb29420faee49e4d38eb2bee31c1c93615ba35a11de05e9",
                "MacAddress": "02:42:c0:a8:00:03",
                "IPv4Address": "192.168.0.3/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]

```

此时，可以通过ping容器名，ping通容器。

```shell
zhengkan03@ubuntu:~/桌面$ docker exec -it tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.148 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.045 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.051 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.044 ms
```

##### 5.网络连通

实现不同网段下的容器之间的通信，如下图，实现tomcat-01与tomcat-net-01之间的通讯；

这个时候的操作是将 容器和网卡进行打通； 如 **tomcat** 与 **mynet** 进行连通

<img src="..\_posts\images\image-20210629142026642.png" alt="image-20210629142026642" style="zoom:67%;" />

![image-20210629141405055](..\_posts\images\image-20210629141405055.png)

```shell
zhengkan03@ubuntu:~/桌面$ docker network connect mynet tomcat-01
zhengkan03@ubuntu:~/桌面$ docker inspect mynet
# 此时相当于将tomcat-01 连接到 mynet下
# 一个容器两个ip地址，相当于一个公网ip，一个私网ip
[
    {
        "Name": "mynet",
        "Id": "ea6c93498361905594f0320ae825995bf71521b4e069ec3aea0dd5f8bc16226e",
        "Created": "2021-06-29T11:59:35.409579492+08:00",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.0.0/16",
                    "Gateway": "192.168.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "3e9947a63101af5fa37f46374234a15971a36db16d5a2882b0c47e25cc90f7e5": {
                "Name": "tomcat-net-01",
                "EndpointID": "ae13601d4fcc64e64a6a86c7213a95afb6f283d5560741120b0eaa466f11503f",
                "MacAddress": "02:42:c0:a8:00:02",
                "IPv4Address": "192.168.0.2/16",
                "IPv6Address": ""
            },
            "6ae5b8586fe601001be4c3700304cfa8ab07b07575ee8aa5b0f2ffb23f300df1": {
                "Name": "tomcat-net-02",
                "EndpointID": "3dd3d12308554f3acbb29420faee49e4d38eb2bee31c1c93615ba35a11de05e9",
                "MacAddress": "02:42:c0:a8:00:03",
                "IPv4Address": "192.168.0.3/16",
                "IPv6Address": ""
            },
            "cc5a993224f7425853e439e0b9142abbf45c0dd0a95bdb421ebd6786d4e5475b": {
                "Name": "tomcat-01",
                "EndpointID": "be1ab5fc75dfe8cc0f9f163687d85c6173eef824c1a18dd6e7821d1c0482773a",
                "MacAddress": "02:42:c0:a8:00:04",
                "IPv4Address": "192.168.0.4/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
```

```shell
# 这个时候就可以实现不同网络中的容器通讯了
zhengkan03@ubuntu:~/桌面$ docker exec -it tomcat-01 ping tomcat-net-01
PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.092 ms
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.053 ms
64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.093 ms
```

##### 6.练习 Redis集群部署

```shell
docker network create redis --subnet 172.38.0.0/16
```

shell 脚本写配置文件

```sh
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-${port}/conf
touch /mydata/redis/node-${port}/conf/redis.conf
cat <<EOF>> /mydata/redis/node-${port}/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes   # 开启集群
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done
```

```shell
# 启动redis
for port in $(seq 1 6);\
do \
docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \
-v /mydata/redis/node-${port}/data:/data \
-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1${port} redis:latest /etc/redis/redis.conf;
done
```

![image-20210629152036305](..\_posts\images\image-20210629152036305.png)

```shell
# 进入一个redis
docker exec -it redis-1 /bin/sh
# 创建集群[集群连接]
redis-cli --cluster create  172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379	--cluster-replicas 1

>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 172.38.0.15:6379 to 172.38.0.11:6379
Adding replica 172.38.0.16:6379 to 172.38.0.12:6379
Adding replica 172.38.0.14:6379 to 172.38.0.13:6379
M: 5d95bc49c537928c7d5536dd314123e5fb487f37 172.38.0.11:6379
   slots:[0-5460] (5461 slots) master
M: 335a096b81b55ba5bcbec4d8634d88770d433860 172.38.0.12:6379
   slots:[5461-10922] (5462 slots) master
M: ca93c3bea05680d01e11167c7eae9cecfaa75974 172.38.0.13:6379
   slots:[10923-16383] (5461 slots) master
S: 73cd8e91ceea92d9162d02e19d59a34dbb3bc005 172.38.0.14:6379
   replicates ca93c3bea05680d01e11167c7eae9cecfaa75974
S: 24ea33a0cd1f7ca39a2a83b811ef37a075984649 172.38.0.15:6379
   replicates 5d95bc49c537928c7d5536dd314123e5fb487f37
S: 86a4f90b1846c79660eff381affaa8acd0a80380 172.38.0.16:6379
   replicates 335a096b81b55ba5bcbec4d8634d88770d433860
Can I set the above configuration? (type 'yes' to accept): yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join
..
>>> Performing Cluster Check (using node 172.38.0.11:6379)
M: 5d95bc49c537928c7d5536dd314123e5fb487f37 172.38.0.11:6379
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
S: 73cd8e91ceea92d9162d02e19d59a34dbb3bc005 172.38.0.14:6379
   slots: (0 slots) slave
   replicates ca93c3bea05680d01e11167c7eae9cecfaa75974
M: ca93c3bea05680d01e11167c7eae9cecfaa75974 172.38.0.13:6379
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
S: 86a4f90b1846c79660eff381affaa8acd0a80380 172.38.0.16:6379
   slots: (0 slots) slave
   replicates 335a096b81b55ba5bcbec4d8634d88770d433860
S: 24ea33a0cd1f7ca39a2a83b811ef37a075984649 172.38.0.15:6379
   slots: (0 slots) slave
   replicates 5d95bc49c537928c7d5536dd314123e5fb487f37
M: 335a096b81b55ba5bcbec4d8634d88770d433860 172.38.0.12:6379
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```

#### Dokcer Compose

基础课程来自【编程不良人】https://www.bilibili.com/video/BV1ZT4y1K75K?p=24

##### 1.docker-compose安装

1. 什么是docker compose

   Compose项目是Docker官方的开源项目，==负责实现对docker容器集群的快速编排==

2. Compose定位

   docker Compose定位是==定义和运行多个Docker容器的应用==

3. Compose核心概念

   服务（service）：一个服务对应着一个应用的容器；服务可以有多个

   项目（project）：由一组关联的应用容器组成的一个完整的业务单元，在**docker-compose.yaml**文件中定义

4. Compose的使用

   a. 下载docker-compose

   ```shell
   $ sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
   ```

   b.  修改权限

   ```shell
   sudo chmod +x /usr/local/bin/docker-compose
   ```

   c. 创建软链接

   ```shell
   sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
   ```

   d. 测试安装成功

   ```shell
    docker-compose --version
    docker-compose version 1.24.1, build 4667896b
   ```

##### 2.docker-compose入门

1. 创建一个docker-compose.yaml文件
2. 在配置文件中定义一个项目存在哪些服务

```yaml
version: "2.4"
service: 
	tomcat:     # 服务名唯一
		image: tomcat:latest  # 设定当前这个服务的镜像
		ports: 
			- 8080:8080  # 宿主（前）映射 服务端口（后）
```

3. 运行docker-compose

   docker-compose up启动这个项目的所有服务，必须保证运行命令的目录存在docker-compose.yml文件

##### 3.docker-compose命令模板

```yaml
version: "3.2"

services:
	tomcat01:
        image: tomcat: 8.0-jre8
        port:
          -"8080":"8080"
        volumes: # 完成宿主机与容器中的数据卷共享
        # 两种方法挂载，一种是绝对路径挂载，具名挂载；另一种是自动创建挂载，属于匿名挂载
          - /root/apps:/usr/local/tomcat/apps/webapps  # 使用自定义路径映射【绝对路径挂载，具名挂载】
          - tomcatwebapps:/usr/local/tomcat/webapps    # 自动创建【在下面需要声明，匿名挂载】
volumes:   # 声明上面服务中所使用的卷名，在 /var/lib/docker/volumes/下自动创建
	tomcatwebapps: #声明指定的卷名 
	external: # 使用外部已经存在的卷名，如果没有，就需要手动创建 docker volume create tomcatwebapps
        true    # 所以这个经常写成false，让系统自动创建卷名
```

具名挂载会挂载到用户定义的的路径下；匿名挂载会挂载到 ==/var/lib/docker/volumes/ 项目名==下，如上面就挂载到了 */var/lib/docker/volumes/* tomcatwebapps 下；

```yaml
version: "3"   # 该代码可以直接运行

services:
    tomcat01:
      container_name: tomcat01   #相当于run的 --name，给容器命名
      image: 
        tomcat:8.0-jre8
      ports:
        - "8080:8080"
      volumes: # 完成宿主机与容器中的数据卷共享
          - tomcatwebapps01:/usr/local/tomcat/webapps    # 自动创建【在下面需要声明，匿名挂载】
      networks:     # 代表当前服务使用哪个网桥，相当于run --network【在下面需要声明】
          - hello 
    
    tomcat02:
      container_name: tomcat02
      image: 
        tomcat:8.0-jre8
      ports:
          - "8081:8080"
      volumes: # 完成宿主机与容器中的数据卷共享
          - tomcatwebapps02:/usr/local/tomcat/webapps    # 自动创建【在下面需要声明，匿名挂载】
      networks:
          - hello
    mysql:  # 启动mysql服务
      image: mysql:5.7.32
      container_name: mysql
      ports:
        - "3307:3306"
      volumes:
        - mysqldata:/var/lib/mysql
        - mysqlconf:/etc/mysql
      environment:
        - MYSQL_ROOT_PASSWORD=root
      networks:
        - hello
volumes:   # 声明上面服务中所使用的卷名，在 /var/lib/docker/volumes/下自动创建
  tomcatwebapps01: #声明指定的卷名 
    external:
      false
  tomcatwebapps02:
  mysqldata:
  mysqlconf:
  
networks:
   hello:
     external:
       false
```

小结：

docker-compose.yml

```yaml
 # 该文件不可复制粘贴直接用
 verison :  ""   # 查看官方文档
  services: #用来书写当前项目中的哪些容器 服务
    demo:
      build:   # 通过Dockerfile打包成镜像
        context: ./demo # 指定docker文件所在文件夹,此时在同级文件夹demo下
        dockerfile: Dockerfile  # 文件名为 Dockerfile
      container_name: demo01
      ports:
        - "8083:8081"
      networks:
        - hello
      depends_on:
        - tomcat01
    tomcat01:																		
          container_name: tomcat01   # 给容器命名，相当于run的 --name
          image: tomcat:8.0-jre8     # 指定镜像文件，image:tag
          ports:				   # 指定主机端口和容器端口的映射关系，相当于 -p
       		- "8080:8080"          
          volumes: 				   # 完成宿主机与容器中的数据卷共享，相当于 -v
            - tomcatwebapps02:/usr/local/tomcat/webapps    # 自动创建【在下面需要声明，匿名挂载】
          networks:                 # 指定容器启动之后使用哪个网桥  --network
            - aa
          cmd: redis-server /....   # 用来覆盖容器默认启动指令
          env_file: # 用来将environment环境中的配置放入环境变量文件中，文件以.env为后缀
          	- ./mysql.env   #表示在当前docker-compose.yml文件路径下的mysql.env文件;.env书写见下面程序
   		 depends_on:   # 解决容器的依赖，设定容器的启动顺序；下面写 服务名，表示在这些服务先启动
         	- tomcat02  # 服务名
         	- redis
         	- mysql
         healthcheck: # 健康检查
         	test: ["CMD","curl","-f","https://localhost"]
         	interval: 1m30s
         	timeout: 10s
         	retries: 3
         sysctls:  # 配置容器内核，用来修改容器中系统内部参数，并不是必须，
           - net.core.somaxconn= 1024 
           - net.ipv4.tcp_syncookies=0
         ulimits: # 用来修改容器中系统内部的进程限制，日后使用时可根据当前容器服务要求进行修改,并不是必须
           nproc: 65535
           nofile:
             soft: 20000
             hard: 40000
         
volumes:
   - tomcatwebapps02:
   
```

.env 文件以键值对进行书写：

```
MYSQL_ROOT_PASSWORD=root
```

##### 4.docker-compose指令

指令：

```yaml
docker-compose -f 文件名.yml            # 根据自定义yml文件启动
			  -p 项目名			   # 自定义项目名
			  --verbose				 # 输出更多调试信息
			  -v					# 版本信息
			  
			  
docker-compose up  [服务名]    # 指定服务名，则启动单一的服务；不指定，全部启动
				-d			# 所有容器后台运行	

docker-compose down			  # 用来关闭所有docker-compose中的服务

docker-compose exec	服务名	bash	# 使用docker-compose 进入容器 （docker-compose.yml中声明的id）

docker-compose ps      			  # 列出项目中的所有的容器【docker-compose.yml】

docker-compose restart [服务名]  		  # 重启服务

docker-compose rm [服务名]			      # 删除项目服务
				-fv					  # 删除服务数据卷
				
docker-compose start [服务名]			# 启动服务
docker-compose stop	 [服务名]			# 停止服务

docker-compose top  		# 用来查看容器内运行的容器

docker-compose pause   [服务名] 	 	# 暂停服务，可通过 docker ps 查看
			  unpause [服务名]
			  
docker-compose logs [服务名]			# 查看日志
```

##### 5.docker可视化工具 Portainer

==Portainer==

官网 ：https://documentation.portainer.io/v2.0/deploy/ceinstalldocker/

```apl
# 1. 创建挂载卷
docker volume create portainer_data
# 2. 启动portainer
docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce	 
# 访问https://localhost:9000 即可访问
```

![image-20210701170626299](..\_posts\images\image-20210701170626299.png)

既然是容器，当然可以直接写入yml文件，一并启动，参与到管理当中；

```yaml
version: "3"   # 该代码可以直接运行,可通过9000端口访问portainer

services:
    tomcat01:
      container_name: tomcat01   #相当于run的 --name，给容器命名
      image: 
        tomcat:8.0-jre8
      ports:
        - "8080:8080"
      volumes: # 完成宿主机与容器中的数据卷共享
          - tomcatwebapps01:/usr/local/tomcat/webapps    # 自动创建【在下面需要声明，匿名挂载】
      networks:     # 代表当前服务使用哪个网桥，相当于run --network【在下面需要声明】
          - hello 
    
    tomcat02:
      container_name: tomcat02
      image: 
        tomcat:8.0-jre8
      ports:
          - "8081:8080"
      volumes: # 完成宿主机与容器中的数据卷共享
          - tomcatwebapps02:/usr/local/tomcat/webapps    # 自动创建【在下面需要声明，匿名挂载】
      networks:
          - hello
    mysql:  # 启动mysql服务
      image: mysql:5.7.32
      container_name: mysql
      ports:
        - "3307:3306"
      volumes:
        - mysqldata:/var/lib/mysql
        - mysqlconf:/etc/mysql
      environment:
        - MYSQL_ROOT_PASSWORD=root
      networks:
        - hello
    portainer:
      image: portainer/portainer-ce
      container_name: portainer
      ports:
        - "8000:8000"
        - "9000:9000"
      volumes:
        - /var/run/docker.sock:/var/run/docker.sock
        - portainer_data:/data
volumes:   # 声明上面服务中所使用的卷名，在 /var/lib/docker/volumes/下自动创建
  tomcatwebapps01: #声明指定的卷名 
    external:
      false
  tomcatwebapps02:
  mysqldata:
  mysqlconf:
  portainer_data:
  
networks:
   hello:
     external:
       false
```





#### Docker Swarm

#### CI/CD
