---
==title: 数据库性能优化
layout: post
tags: 数据库
categories: ''
---

# NumPy

官方帮助文档 https://www.numpy.org.cn/user/

NumPy是Python中科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。

NumPy包的核心是 *ndarray* 对象。它封装了python原生的同数据类型的 *n* 维数组，为了保证其性能优良，其中有许多操作都是代码在本地进行编译后执行的。

### 1.矩阵生成

#### 	1.1一般矩阵

```python
# 使用arange创建序列
>>> import numpy as np
>>> a = np.arange(15).reshape(3, 5)
>>> a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])	

# 使用array创建    一维数组
>>> import numpy as np
>>> a = np.array([2,3,4])
>>> a
array([2, 3, 4])

# 二位数组
>>> b = np.array([(1.5,2,3), (4,5,6)])
>>> b
array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])
# 复数数组
>>> c = np.array( [ [1,2], [3,4] ], dtype=complex )
>>> c
array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])

# 间隔生成 一维数组
np.linspace(2.0, 3.0, num=5)				# 此处num为采样生成个数，默认是50
array([2.  , 2.25, 2.5 , 2.75, 3.  ])			
np.linspace(2.0, 3.0, num=5, endpoint=False)  # 此处endpoint默认是True，即包含最后一个数
array([2. ,  2.2,  2.4,  2.6,  2.8])
np.linspace(2.0, 3.0, num=5, retstep=True)	  # 此处retstep默认为False，开启则返回间隔大小
(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
```

#### 1.2 二维矩阵

```python
# meshgrid
nx, ny = (3, 2)
x = np.linspace(0, 1, nx)
y = np.linspace(0, 1, ny)
xv, yv = np.meshgrid(x, y)
xv
array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])
yv
array([[0.,  0.,  0.],
       [1.,  1.,  1.]])
xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays
xv
array([[0. ,  0.5,  1. ]])
yv
array([[0.],
       [1.]])
# meshgrid 用于绘制三维图形
import matplotlib.pyplot as plt
x = np.arange(-5, 5, 0.1)
y = np.arange(-5, 5, 0.1)
xx, yy = np.meshgrid(x, y, sparse=True)
z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)
h = plt.contourf(x, y, z)
plt.axis('scaled')
plt.show()
```

#### 2.空矩阵

```python
np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized 为随机值
```

#### 3.空相似矩阵

```python
a = ([1,2,3], [4,5,6])                         # a is array-like
np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821]])	
```

#### 4.单位矩阵

```python
np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])

np.eye(3, k=1)          # k可以选择单位对角线
array([[0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.]])


np.identity(3)			# 只能是对角单位阵
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])
```

#### 5.全一矩阵

```python
# 一维
np.ones(5)
array([1., 1., 1., 1., 1.])

np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])
# 二维
s = (2,2)
np.ones(s)
array([[1.,  1.],
       [1.,  1.]])
```

#### 6.全一相似阵

```python
x = np.arange(6)
x = x.reshape((2, 3))
x
array([[0, 1, 2],
       [3, 4, 5]])
np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])
```

#### 7.零矩阵

```python
# 一维
np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

np.zeros((5,), dtype=int)
array([0, 0, 0, 0, 0])
# 二维
s = (2,2)
np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])
```

#### 8.全零相似阵

```python
x = np.arange(6)
x = x.reshape((2, 3))
x
array([[0, 1, 2],
       [3, 4, 5]])
np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])
```

#### 9.全N矩阵

```python
np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])

np.full((2, 2), [1, 2])
array([[1, 2],
       [1, 2]])
```

#### 10.全N相似阵

```python
x = np.arange(6, dtype=int)
np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
np.full_like(x, 0.1, dtype=np.double) # 注意数据类型
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
np.full_like(x, np.nan, dtype=np.double)
array([nan, nan, nan, nan, nan, nan])

y = np.arange(6, dtype=np.double)
np.full_like(y, 0.1)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
```

#### 11.对角矩阵

```python
x = np.arange(9).reshape((3,3))
x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

# 获取对角阵的值
np.diag(x)
array([0, 4, 8])
np.diag(x, k=1)
array([1, 5])
np.diag(x, k=-1)
array([3, 7])

# 创建对角阵
np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])
```

#### 12.随机矩阵

```python
np.random.seed(123)
import numpy.matlib
np.matlib.rand(2, 3)
matrix([[0.69646919, 0.28613933, 0.22685145],
        [0.55131477, 0.71946897, 0.42310646]])
np.matlib.rand((2, 3))
matrix([[0.9807642 , 0.68482974, 0.4809319 ],
        [0.39211752, 0.34317802, 0.72904971]])
```

#### 13.正态分布矩阵

```python
np.random.seed(123)
import numpy.matlib
np.matlib.randn(1)
matrix([[-1.0856306]])
np.matlib.randn(1, 2, 3)
matrix([[ 0.99734545,  0.2829785 , -1.50629471],
        [-0.57860025,  1.65143654, -2.42667924]])
```



### 2.矩阵操作

#### 1.查询行列数

```python
np.shape(np.eye(3))
(3, 3)
np.shape([[1, 2]])
(1, 2)
np.shape([0])
(1,)
np.shape(0)
()
```

#### 2.重塑矩阵

```python
np.reshape(a, (2, 3)) # C-like index ordering    生成新行列的矩阵，不改变原矩阵
array([[0, 1, 2],
       [3, 4, 5]])
np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
array([[0, 4, 3],
       [2, 1, 5]])
```

#### 3.1矩阵降维【降成一维】

```python
x = np.array([[1, 2, 3], [4, 5, 6]])
np.ravel(x)
array([1, 2, 3, 4, 5, 6])	 # 返回的是视图，修改视图，原始矩阵也会被修改
```

#### 3.2矩阵降维【降成一维】

```python
a = np.array([[1,2], [3,4]])
a.flatten()
array([1, 2, 3, 4])			# 返回的是拷贝对象，修改不影响原始矩阵
```

#### 4.矩阵转置

```python
x = np.array([[1.,2.],[3.,4.]])   # .transpose = .T
x
array([[ 1.,  2.],
       [ 3.,  4.]])
x.T
array([[ 1.,  3.],
       [ 2.,  4.]])
```

#### 5.矩阵广播

```python
x = np.array([1, 2, 3])            
np.broadcast_to(x, (3, 3))		# 将一维广播到三维
array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]])
```

#### 6.删除单维度条目

```python
x = np.array([[[0], [1], [2]]])  
x.shape
(1, 3, 1)
np.squeeze(x).shape 			# 删除维度为1的条目
(3,)
```

#### 7.转换数据类型

```python
np.asfarray([2, 3])              # 转换为浮点型
array([2.,  3.])
np.asfarray([2, 3], dtype='float')
array([2.,  3.])
np.asfarray([2, 3], dtype='int8')
array([2.,  3.])


np.asscalar(np.array([24]))		# 转换维度为1的矩阵为标量
24
```

#### 8.矩阵拼接

```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])
np.concatenate((a, b), axis=0)   # 沿0轴拼接，二维0轴就是行 shape => (0,1)
array([[1, 2],
       [3, 4],
       [5, 6]])

np.concatenate((a, b.T), axis=1) # 沿1轴拼接，就是列
array([[1, 2, 5],
       [3, 4, 6]])

np.concatenate((a, b), axis=None) # axis为none,flatten后拼接
array([1, 2, 3, 4, 5, 6])

# vstack 上下拼接--直观一些 --垂直 沿着0轴拼接
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
np.vstack((a,b))
array([[1, 2, 3],
       [4, 5, 6]])

# hstack 左右拼接--水平  沿着1轴拼接
a = np.array([[1],[2],[3]])
b = np.array([[4],[5],[6]])
np.hstack((a,b))
array([[1, 4],
       [2, 5],
       [3, 6]])
```

#### 9.矩阵分割

```python
# vsplit 上下分割 -- 垂直 沿着0轴分割
x = np.arange(16.0).reshape(4, 4)
x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
np.vsplit(x, 2)
[array([[0., 1., 2., 3.],
       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],
       [12., 13., 14., 15.]])]

np.vsplit(x, np.array([3, 6]))
[array([[ 0.,  1.,  2.,  3.],
       [ 4.,  5.,  6.,  7.],
       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]
# hsplit 左右分割 -- 水平 沿着1轴分割
x = np.arange(16.0).reshape(4, 4)
x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
np.hsplit(x, 2)
[array([[  0.,   1.],
       [  4.,   5.],
       [  8.,   9.],
       [12.,  13.]]),
 array([[  2.,   3.],
       [  6.,   7.],
       [10.,  11.],
       [14.,  15.]])]
np.hsplit(x, np.array([3, 6]))
[array([[ 0.,   1.,   2.],
       [ 4.,   5.,   6.],
       [ 8.,   9.,  10.],
       [12.,  13.,  14.]]),
 array([[ 3.],
       [ 7.],
       [11.],
       [15.]]),
 array([], shape=(4, 0), dtype=float64)]
```

#### 10.复制生成矩阵

```python
np.repeat(3, 4)					# 将3复制4次
array([3, 3, 3, 3])     
x = np.array([[1,2],[3,4]])		
np.repeat(x, 2)					# 将x元素复制两次，不指定axis，复制后自动flatten	
array([1, 1, 2, 2, 3, 3, 4, 4])
np.repeat(x, 3, axis=1)			# 将x沿着列三次
array([[1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4]])
np.repeat(x, [1, 2], axis=0)     # 将x第一项复制1次，将x第二项复制两次，沿着行复制
array([[1, 2],
       [3, 4],
       [3, 4]])
```

#### 11.矩阵删除

```python
arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
arr
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])
np.delete(arr, 1, axis=0)			# 删除第二行	，axis = 1就是删除第二列
array([[ 1,  2,  3,  4],
       [ 9, 10, 11, 12]])
```

#### 12.插入行列

```python
a = np.array([[1, 1], [2, 2], [3, 3]])
a
array([[1, 1],
       [2, 2],
       [3, 3]])
np.insert(a, 1, 5)					# 不指定axis，先将a flatten操作再插入数据
array([1, 5, 1, ..., 2, 3, 3])
np.insert(a, obj=1, 5, axis=1)			# 指定axis为1，在obj列位置插入5
array([[1, 5, 1],	
       [2, 5, 2],
       [3, 5, 3]])
```

#### 13.追加数据

```python
np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)	# 追加数据需要保持维度正确，否则报错

Traceback (most recent call last):
    ...
ValueError: all the input arrays must have same number of dimensions, but
the array at index 0 has 2 dimension(s) and the array at index 1 has 1
dimension(s)
```

#### 14.矩阵翻折

```python
A = np.arange(8).reshape((2,2,2))
A
array([[[0, 1],
        [2, 3]],
       [[4, 5],
        [6, 7]]])
np.flip(A, 0)								# 三维矩阵的轴，axis=0为外层括号扩展方向，即深；
array([[[4, 5],								# axis =1 为第二层括号扩展方向，，即列
        [6, 7]],							# axis =2 最内层括号扩展方向，即行
       [[0, 1],
        [2, 3]]])
np.flip(A, 1)
array([[[2, 3],
        [0, 1]],
       [[6, 7],
        [4, 5]]])
np.flip(A)
array([[[7, 6],
        [5, 4]],
       [[3, 2],
        [1, 0]]])
np.flip(A, (0, 2))
array([[[5, 4],
        [7, 6]],
       [[1, 0],
        [3, 2]]])
A = np.random.randn(3,4,5)
np.all(np.flip(A,2) == A[:,:,::-1,...])
```

### 3.数据统计

#### 1.最值

```python
a = np.arange(4).reshape((2,2))
a
array([[0, 1],
       [2, 3]])
np.amin(a)           # Minimum of the flattened array	最小值amin；最大值amax
0
np.amin(a, axis=0)   # Minima along the first axis
array([0, 1])
np.amin(a, axis=1)   # Minima along the second axis
array([0, 2])

a = np.array([[1, 2], [3, np.nan]])			# 排除NaN的最值查询；最小值 nanmin；最大值nanmax
np.nanmin(a)
1.0
np.nanmin(a, axis=0)
array([1.,  2.])
np.nanmin(a, axis=1)
array([1.,  3.])
```

#### 2.幅值计算

```python
x = np.array([[4, 9, 2, 10],
              [6, 9, 7, 12]])
np.ptp(x, axis=1)					# 计算列幅值 peak2peak
array([8, 6])

np.ptp(x, axis=0)					# 行幅值 沿着0轴方向
array([2, 0, 5, 2])
```

#### 3.四分位数计算

```python
a = np.array([[10, 7, 4], [3, 2, 1]])
a
array([[10,  7,  4],
       [ 3,  2,  1]])
np.quantile(a, 0.5)
3.5
np.quantile(a, 0.5, axis=0)						# 中位数，第二四分位数(Q2)

array([6.5, 4.5, 2.5])
np.quantile(a, 0.5, axis=1)
array([7.,  2.])
np.quantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
```

#### 4.均值计算

```python
data = np.arange(1, 5)							# 一维均值计算
data
array([1, 2, 3, 4])				

data = np.arange(6).reshape((3,2))
data
array([[0, 1],
       [2, 3],
       [4, 5]])
np.average(data, axis=1, weights=[1./4, 3./4])		# 加权重的均值计算
array([0.75, 2.75, 4.75])

a = np.array([[1, 2], [3, 4]])					  # 绝对均值计算 mean
np.mean(a)
2.5
np.mean(a, axis=0)
array([2., 3.])
np.mean(a, axis=1)
array([1.5, 3.5])
```

#### 5.标准差计算

```python
# std = sqrt(mean(x)), where x = abs(a - a.mean())**2
a = np.array([[1, 2], [3, 4]])
np.std(a)
1.1180339887498949 # may vary
np.std(a, axis=0)
array([1.,  1.])
np.std(a, axis=1)
array([0.5,  0.5])
```

#### 6.方差计算

```python
 # var = mean(x), where x = abs(a - a.mean())**2.
 a = np.array([[1, 2], [3, 4]])
 np.var(a)
 1.25
 np.var(a, axis=0)
 array([1.,  1.])
 np.var(a, axis=1)
 array([0.25,  0.25])
```

#### 7.中位数计算

```python
a = np.array([[10, 7, 4], [3, 2, 1]])		# 排除nan的中位数计算 nanmedian
a
array([[10,  7,  4],
       [ 3,  2,  1]])
np.median(a)
3.5
np.median(a, axis=0)
array([6.5, 4.5, 2.5])
np.median(a, axis=1)
array([7.,  2.])
```

#### 8.相关性系数计算

```python
import numpy as np
rng = np.random.default_rng(seed=42)
xarr = rng.random((3, 3))
xarr
array([[0.77395605, 0.43887844, 0.85859792],
       [0.69736803, 0.09417735, 0.97562235],
       [0.7611397 , 0.78606431, 0.12811363]])
R1 = np.corrcoef(xarr)
R1
array([[ 1.        ,  0.99256089, -0.68080986],
       [ 0.99256089,  1.        , -0.76492172],
       [-0.68080986, -0.76492172,  1.        ]])
```

#### 9.协方差计算

```python
x = np.array([[0, 2], [1, 1], [2, 0]]).T
x
array([[0, 1, 2],
       [2, 1, 0]])

np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])
```

### 4.科学计算

#### 1.三角函数sin，cos，tan

#### 2.反三角函数arcsin，arccos，arctan

```python
# 注意以弧度表示
np.sin(np.pi/2.)
1.0

np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )			# 数组正弦值求解	
array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])

import matplotlib.pylab as plt
x = np.linspace(-np.pi, np.pi, 201)
plt.plot(x, np.sin(x))
plt.xlabel('Angle [rad]')
plt.ylabel('sin(x)')
plt.axis('tight')
plt.show()
```

#### 3.弧度角度

```python
rad = np.arange(12.)*np.pi/6
np.rad2deg(rad)					# 弧度转角度
array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,
        270.,  300.,  330.])

eg = np.arange(12.) * 30.		# 角度转弧度
np.deg2rad(deg)
array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,
        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,
        5.23598776,  5.75958653])
```

#### 4.双曲函数sinh、cosh、tanh

#### 5.反双曲函数arcsinh、arccosh、arctanh

```python
p.sinh(0)
0.0
np.sinh(np.pi*1j/2)
1j
np.sinh(np.pi*1j) # (exact value is 0)
1.2246063538223773e-016j

np.arcsinh(np.array([np.e, 10.0]))
array([ 1.72538256,  2.99822295])
```

#### 6.近似值

```python
np.around([0.37, 1.64])				
array([0.,  2.])
np.around([0.37, 1.64], decimals=1)
array([0.4,  1.6])
np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
array([0.,  2.,  2.,  4.,  4.])
np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
array([ 1,  2,  3, 11])
np.around([1,2,3,11], decimals=-1)
array([ 0,  0,  0, 10])
```

#### 7.近似最近整数

```python
a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
np.rint(a)
array([-2., -2., -0.,  0.,  2.,  2.,  2.])
```

#### 8.近似向上取整

```python
a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
np.ceil(a)
array([-1., -1., -0.,  1.,  2.,  2.,  2.])
```

#### 9.向0取整

```python
a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])
np.trunc(a)
array([-1., -1., -0.,  0.,  1.,  1.,  2.])
```

#### 10.梯度计算

```python
# 一维数组梯度计算
# 梯度计算,当每个数间隔位1时
# 首位 ： （2-1）/1 = 1
# 中间位： （4-1）/2 = 1.5 ； (7-2)/2 = 2.5
# 末位 ：	(16-11)/1 = 5
f = np.array([1, 2, 4, 7, 11, 16], dtype=float) 
np.gradient(f)
array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])

# 当每个数间隔位2时
np.gradient(f, 2)
array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
```

```python
# 二维数据梯度计算
# 返回两个矩阵，第一个矩阵为最外层维度梯度；第二个为内层维度梯度
# 第一个矩阵 1 = 3-2；-14 =4-18；
# 第二个矩阵 16 = 18-2；6.5=(15-2)/2
aaa
array([[ 2, 18, 15, 19, 14],
       [ 3,  4,  5,  4,  2],
       [15,  2,  3, 18,  5]])
>>> np.gradient(aaa)
[array([[  1. , -14. , -10. , -15. , -12. ],
       [  6.5,  -8. ,  -6. ,  -0.5,  -4.5],
       [ 12. ,  -2. ,  -2. ,  14. ,   3. ]]), 
 array([[ 16. ,   6.5,   0.5,  -0.5,  -5. ],
       [  1. ,   1. ,   0. ,  -1.5,  -2. ],
       [-13. ,  -6. ,   8. ,   1. , -13. ]])]
```

### 5.矩阵计算

参考官方 ：https://numpy.org/devdocs/reference/routines.linalg.html

#### 1.矩阵乘法

```python
np.dot(3, 4)
12

a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
np.dot(a, b)
array([[4, 1],
       [2, 2]])
```

#### 2.矩阵内乘法

```python
# 对应元素相乘再相加 np.inner(a, b) = sum(a[:]*b[:]) ; np.inner(a,b) = a*b 
a = np.array([1,2,3])
b = np.array([0,1,0])
np.inner(a, b)
2
```

#### 3.矩阵指定轴元素相乘

```python
# 一维所有元素相乘				=> nanprod()
np.prod([1.,2.])
2.0
# 二维不指定轴，当做一维处理
np.prod([[1.,2.],[3.,4.]])
24.0
# 二维指定轴，沿列方向延展，即每一行所有元素相乘
np.prod([[1.,2.],[3.,4.]], axis=1)
array([  2.,  12.])
```

#### 4.矩阵指定轴元素相加

```python
# 一维默认所有元素相加			=> nansum()
np.sum([0.5, 1.5])
2.0
# 二维不指定轴，按照一维处理
np.sum([[0, 1], [0, 5]])
6
# 指定轴为0轴，沿着行展开的方向，即每列元素相加
np.sum([[0, 1], [0, 5]], axis=0)
array([0, 6])
```

#### 5.矩阵求解

Solve the system of equations `x0 + 2 * x1 = 1` and `3 * x0 + 5 * x1 = 2`:

```python
>>> a = np.array([[1, 2], [3, 5]])
>>> b = np.array([1, 2])
>>> x = np.linalg.solve(a, b)
>>> x
array([-1.,  1.])
```

#### 6.线性矩阵最小二乘解

Fit a line, `y = mx + c`, through some noisy data-points:

```python
x = np.array([0, 1, 2, 3])
y = np.array([-1, 0.2, 0.9, 2.1])
# We can rewrite the line equation as y = Ap, where A = [[x 1]] and p = [[m], [c]]. Now use lstsq to solve for p:
A = np.vstack([x, np.ones(len(x))]).T
A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])
m, c = np.linalg.lstsq(A, y, rcond=None)[0]
m, c
(1.0 -0.95) # may vary

# 拟合曲线验证
import matplotlib.pyplot as plt
_ = plt.plot(x, y, 'o', label='Original data', markersize=10)
_ = plt.plot(x, m*x + c, 'r', label='Fitted line')
_ = plt.legend()
plt.show()
```

