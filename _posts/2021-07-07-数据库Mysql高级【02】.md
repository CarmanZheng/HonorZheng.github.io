---
title: 数据库Mysql高级【02】
layout: post
tags: 数据库
categories: ''
---

## 1.Mysql体系架构

![img](..\_posts\images\1210730-20181012171930836-677209096.png)

由图，可以看出MySQL最上层是连接组件。下面服务器是由连接池、管理工具和服务、SQL接口、解析器、优化器、缓存、存储引擎、文件系统组成。

**连接池**：由于每次建立建立需要消耗很多时间，连接池的作用就是将这些连接缓存下来，下次可以直接用已经建立好的连接，提升服务器性能。
**管理工具和服务**：系统管理和控制工具，例如备份恢复、Mysql复制、集群等
**SQL接口（SQL Interface)**：接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface
**解析器（parse）**: SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本

```mysql
主要功能：
a . 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的
b. 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的
```

**优化器(Optimizer)**：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是“选取-投影-联接”策略进行查询。

```mysql
用一个例子就可以理解：
select uid,name from user where gender = 1;
这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤
这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤
将这两个查询条件联接起来生成最终查询结果
```

**缓存器（cache&buffer）**： 查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。
通过LRU算法将数据的冷端溢出，未来得及时刷新到磁盘的数据页，叫脏页。
这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等

## 2.存储引擎

​		和大多数的数据库不同，Mysql中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。

​		存储引擎就是存储数据、简历索引、更新查询数据等等技术的实现方式。**存储引擎是基于表的**，不是基于库的，所以存储引擎也可被成为表类型。

​		**Oracle、Sqlserver等数据库中只有一种存储引擎**。Mysql提供了插件式的存储引擎架构，多种引擎可以供选用。

```mysql
# 查看存储引擎
show engines;
```

### 1.引擎特征

InnoDB支持事务、行级锁和外键，是Mysql默认存储引擎。

MyISAM支持表锁、不支持事务，其优势是访问的速度快。每个MyISAM在磁盘上存储3个文件，其文件名都和表名相同，但是拓展分别为：

```
.frm 		存储表定义
.MYD		存储数据 MYData
.MYI		存储索引 MYIndex
```

| Feature                                | MyISAM       | Memory           | InnoDB       | Archive      | NDB          |
| :------------------------------------- | :----------- | :--------------- | :----------- | :----------- | :----------- |
| B-tree indexes                         | ==Yes==      | Yes              | ==Yes==      | No           | No           |
| Backup/point-in-time recovery (note 1) | Yes          | Yes              | Yes          | Yes          | Yes          |
| Cluster database support               | No           | No               | No           | No           | Yes          |
| Clustered indexes                      | No           | No               | Yes          | No           | No           |
| Compressed data                        | Yes (note 2) | No               | Yes          | Yes          | No           |
| Data caches                            | ==No==       | N/A              | ==Yes==      | No           | Yes          |
| Encrypted data                         | Yes (note 3) | Yes (note 3)     | Yes (note 4) | Yes (note 3) | Yes (note 3) |
| Foreign key support                    | ==No==       | No               | ==Yes==      | No           | Yes (note 5) |
| Full-text search indexes               | Yes          | No               | Yes (note 6) | No           | No           |
| Geospatial data type support           | Yes          | No               | Yes          | Yes          | Yes          |
| Geospatial indexing support            | Yes          | No               | Yes (note 7) | No           | No           |
| Hash indexes                           | No           | Yes              | No (note 8)  | No           | Yes          |
| Index caches                           | Yes          | N/A              | Yes          | No           | Yes          |
| Locking granularity                    | ==Table==    | Table            | ==Row==      | Row          | Row          |
| MVCC                                   | ==No==       | No               | ==Yes==      | No           | No           |
| Replication support (note 1)           | Yes          | Limited (note 9) | Yes          | Yes          | Yes          |
| Storage limits                         | 256TB        | RAM              | 64TB         | None         | 384EB        |
| T-tree indexes                         | No           | No               | No           | No           | Yes          |
| Transactions                           | ==No==       | No               | ==Yes==      | No           | Yes          |
| Update statistics for data dictionary  | Yes          | Yes              | Yes          | Yes          | Yes          |

1. 在服务器中实现，而不是在存储引擎中。

2. 压缩 MyISAM 表仅在使用压缩行格式时才受支持。使用 MyISAM 压缩行格式的表是只读的。

3. 通过加密功能在服务器中实现。

4. 通过加密功能在服务器中实现；在 MySQL 5.7 及更高版本中，支持静态数据加密。

5. MySQL Cluster NDB 7.3 及更高版本支持外键。

6. MySQL 5.6 及更高版本支持 FULLTEXT 索引。

7. MySQL 5.7 及更高版本支持地理空间索引。

8. InnoDB 在内部利用哈希索引来实现其自适应哈希索引功能。

9. 参见本节后面的讨论。

### 2.引擎选择 

MySQL数据库中最重要的一个概念就是数据库引擎，不同的数据库引擎的工作原理存在很大差异最终造成MySQL数据库服务的性能差异。例如如果数据库引擎需要支持事务，就必须满足事务的基本特性——AICD特性（AICD：原子性、隔离性、一致性和永久性。属于基础知识所以不在这里赘述），那么自然就需要一定处理机制来实现这些特性。这样做的现实效果就是导致写入同样数据量的情况下，支持事务的数据库引擎比不支持事务的数据库引擎耗费更多的时间。这里我们首先为读者列举MySQL数据库社区版中支持的数据库引擎（部分）：

**MEMORY**：MEMORY存储引擎将表的数据完全存放在内存中。在MySQL数据库的历史版本中和该数据库引擎类似的其它引擎是HEAP，后者曾是MySQL数据库中访问速度最快的数据库引擎。但由于这两种数据库引擎完全工作在内存中，所以如果MySQL或者服务器重新启动，数据库引擎中保存的数据将会丢失。

**BLACKHOLE**：中文名“黑洞”，使用BLACKHOLE数据库引擎的数据表不存储任何数据，只根据数据库操作过程记录二进制日志。它的主要作用是作为MySQL主从复制的中继器，并且可以在其上面添加业务过滤机制。

**MyISAM**：MyISAM数据库引擎是MySQL数据库默认的数据库引擎。MyISAM使用一种表格锁定的机制，来优化多个并发的读写操作（实际上就是使用的一种避免数据脏读的机制）。但是这种机制对存储空间的使用有一定的浪费。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MYISAMCHK工具和用来恢复浪费空间的MYISAMPACK工具。本文所介绍的MySQL数据库相关技术将不涉及到这种数据库引擎。

**InnoDB**：InnoDB数据库引擎是在各种版本的MySQL数据库中使用最广泛的一种数据库引擎，本文后续的介绍中如果没有特别说明都默认是在说InnoDB数据库引擎。InnoDB数据库引擎使用日志机制提供事务的支持。
————————————————
原文链接：https://blog.csdn.net/qq_44836294/article/details/107619467

### 3.优化SQL步骤

#### 1.查询SQL执行频率

在应用的开发过程中，由于初期数据量小，开发人员写SQL语句时更加重视功能上的实现，但是当应用系统正式上线后，随着生产 数据量的集聚增长，很多SQL语句开始逐渐显露出性能问题，对生产的影响越来越大，此时这些有问题的SQL语句就成为了整个系统的性能瓶颈，因此我们必须对他们进行优化。

```mysql
# 查询数据库各种操作的统计
show global status like "Com_______";
# 查询innodb中各种操作的统计
show global status like "Innodb_row_%";
```

#### 2.定位低效率执行SQL

可以通过一下两种方式定位执行效率较低的SQL语句

* 慢查询日志：通过慢查询日志定位那些执行效率低的SQL语句，用`--log-slow-queries[=file_name]`选项启动是，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。

* `show processlist`：慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候，查询日志并不能定位问题。此时，使用`show processlist`命令可以查看当前Mysql在进行的线程，包括线程的状态、是否锁表等。同时，可以对一些锁表操作进行优化。

  ![image-20210720151958358](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210720151958358.png)

  

| 列名    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| id      | 用户登录mysql时，系统分配的connection_id                     |
| user    | 显示当前用户，如果不是root，这个命令只显示用户权限范围的sql语句 |
| host    | 发出操作语句的主机ip和端口                                   |
| db      | 显示这个进程目前连接的数据库名称                             |
| command | 显示当前连接执行的命令，休眠（Sleep）、查询（Query)、连接（connect）等 |
| time    | 显示这个状态持续的时间，单位为秒                             |
| state   | 显示当前连接sql语句的状态                                    |
| info    | 显示当前执行的sql语句                                        |

#### 3.explain分析执行计划

在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。

![image-20210721140936109](..\_posts\images\image-20210721140936109.png)

expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra

| 项目          | 说明                       |
| ------------- | -------------------------- |
| id            | 选择标识符                 |
| select_type   | 表示查询的类型             |
| table         | 输出结果集的表             |
| partitions    | 匹配的分区                 |
| type          | 表示表的连接类型           |
| possible_keys | 查询时可能用到的索引       |
| key           | 查询时实际使用的索引       |
| key_len       | 索引字段的长度             |
| ref           | 列与 索引的比较            |
| rows          | 扫描出的行数（估算的行数） |
| filtered      | 按表条件过滤的行百分比     |
| Extra         | 执行情况的描述和说明       |

##### id

​	id是SELECT的查询序列号，是一组数字，表示的是查询中执行的select子句或者是**操作表的顺序**。

​	id情况有三种，举例说明，先建表：

```mysql
# 创建角色表
create table t_role(
id varchar(32) 	not null,
role_name varchar(255) default null,
role_code varchar(255) default null,
description varchar(255) default null,
primary key(id),
unique key unique_role_name(role_name)
)ENGINE=InnoDB default charset=utf8;
```

```MYSQL
# 创建用户表
create table t_user(
id varchar(32) 	not null,
username varchar(45) not null,
password varchar(96) not null,
name varchar(45) not null,
primary key(id),
unique key unique_user_username(username)
)ENGINE=InnoDB default charset=utf8;
```

```MYSQL
# 创建用户角色表
create table user_role(
id int(11) not null auto_increment,
user_id varchar(32) not null,
role_id varchar(32) not null,
primary key(id),
key fk_user_id(user_id),
key fk_role_id(role_id),
constraint fk_ur_role_id foreign key(role_id) references t_role(id) on DELETE NO ACTION on UPDATE NO ACTION,
constraint fk_ur_user_id foreign key(user_id) references t_user(id) on DELETE NO ACTION on UPDATE NO ACTION
)ENGINE=InnoDB default charset=utf8;
```

```mysql
insert into t_user(id,username,password,name) values(1,'super','6df93e89ee7c11ea8be9f875a471a574','超级管理员');
insert into t_user(id,username,password,name) values(2,'admin','6df93e89ee7c11ea8be9f875a471a574','系统管理员');
insert into t_user(id,username,password,name) values(3,'itcast','a3d8793cee7c11ea8be9f875a471a574','test02');
insert into t_user(id,username,password,name) values(4,'stu1','b8c1a8ffee7c11ea8be9f875a471a574','学生1');
insert into t_user(id,username,password,name) values(5,'stu2','c0cb5c46ee7c11ea8be9f875a471a574','学生2');
insert into t_user(id,username,password,name) values(6,'t1','c86cbf6cee7c11ea8be9f875a471a574','老师1');


insert into t_role(id,role_name,role_code,description) values(5,'学生','student','学生');
insert into t_role(id,role_name,role_code,description) values(7,'老师','teacher','老师');
insert into t_role(id,role_name,role_code,description) values(8,'教学管理员','teachmanager','教学管理员');
insert into t_role(id,role_name,role_code,description) values(9,'管理员','admin','管理员');
insert into t_role(id,role_name,role_code,description) values(10,'超级管理员','super','超级管理员');

insert into user_role(id,user_id,role_id) values(1,1,5);
insert into user_role(id,user_id,role_id) values(2,1,7);
insert into user_role(id,user_id,role_id) values(3,2,8);
insert into user_role(id,user_id,role_id) values(4,3,9);
insert into user_role(id,user_id,role_id) values(5,4,8);
insert into user_role(id,user_id,role_id) values(6,5,10);
```

![image-20210721142819026](..\_posts\images\image-20210721142819026.png)

1.id相同表示加载表的顺序从上而下加载

```mysql
explain select * from t_role r,t_user u ,user_role ur where r.id = ur.role_id and u.id = ur.user_id;
```

![image-20210721143138286](..\_posts\images\image-20210721143138286.png)

2.id越大，优先级越高

​	如在嵌套查询中，子查询就优先。此时id为3的数据是最先查询的，其次为id=2，最后是id=1

```mysql
explain select * from t_role where id =(select role_id from user_role where user_id = (select id from t_user where username ='stu1'));
```

![image-20210721143751897](..\_posts\images\image-20210721143751897.png)

3.id相同，也有不同，同时存在。 id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大优先级越高，越先执行。

```mysql
explain select * from t_role r,(select * from user_role ur where ur.`user_id` ='2') a where r.id=a.role_id;
```

![image-20210721150104868](..\_posts\images\image-20210721150104868.png)

##### select_type

| 项目     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| SIMPLE   | 简单的SELECT查询，不使用UNION或者子查询                      |
| PRIMARY  | 在含有子查询的查询中，最外层的SELECT被标记为PRIMARY          |
| UNION    | 第二个SELECT出现在UNION之后，则被标记为UNION;  若UNION中包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED（衍生） |
| DERIVED  | 在FROM列表中包含子查询，被标记为DERIVED；Mysql会递归执行这些子查询，把结果放在临时表中 |
| SUBQUERY | 子查询，如SELECT或WHERE中就包含了子查询                      |

越往下越慢，SIMPLE最快。

##### table

当前查询的数据来源

##### type

type显示的是访问类型

| 项目   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| NULL   | MYSQL不访问任何表、索引，直接返回结果                        |
| system | 只有一行数据的表                                             |
| const  | 表示通过索引一次就找到了                                     |
| eq_ref | 类似ref，区别在于使用的是唯一索引，多表关联查询只有一条数据，就会显示eq_ref |
| ref    | 非唯一索引查询，记录可能有多条                               |
| range  | 只检索给定返回的行，使用一个索引选择行；where之后出现between、<、>、in等操作 |
| index  | index与ALL的区别为index类型只是遍历了索引树，通常比ALL快，ALL是遍历数据文件 |
| all    | 遍历全表，以找到匹配的行                                     |

结果值最好到最坏

```mysql
NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_range > unique_subquery > index_subquery > range > index > all

# 一般要求至少达到range级别，最好达到ref
```

##### key

```mysql
possible_keys:	 显示可能应用在这张表的索引，一个或多个
key:			实际使用的索引，如果为NULL，则没有使用索引
key_len:		表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
```

##### rows

查询过程中扫描的行

##### Extra

其他额外的执行计划信息，在该列展示

| extra           | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| using filesort  | 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，称为“文件排序”，效率低 |
| using temporary | 使用了临时表保存中间结果，mysql在查询结果排序时使用临时表。常见于order by ，group by |
| using index     | 表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错 |

#### 4.show profile分析SQL

show profile能够在做SQL优化时帮助我们分析时间都去哪儿了

```mysql
select @@have_profiling	;  # 判断是否具有profilinng功能
# 0 为未开启；1 为开启
select @@profiling;
set profiling = 1 ;
```

<img src="..\_posts\images\image-20210721160805500.png" alt="image-20210721160805500" style="zoom:80%;" />

```mysql
show profile for query 3;
```

<img src="..\_posts\images\image-20210721160917634.png" alt="image-20210721160917634" style="zoom:80%;" />

#### 5.trace分析优化器的执行计划

通过trace文件能够进一步了解为什么优化器选择A计划，而不是B计划；

打开trace，设置格式为JSON,并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

```mysql
set optimizer_trace = "enabled=on",end_markers_in_json=on;
set optimizer_trace_max_mem_size=1000000;
```

执行sql语句：

```mysql
select * from t_user where id < 4;
```

最后检查information_schema.optimizer_trace就可以知道Mysql执行SQL的过程：

```MYSQL
select * from information_schema.optimizer_trace\G;
```

![image-20210721162130226](..\_posts\images\image-20210721162130226.png)

### 4.索引的使用

索引是数据库优化最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数mysql的性能问题。

```mysql
create table tb_seller(
sellerid varchar(100),
name varchar(100),
nickname varchar(50),
password varchar(60),
status varchar(1),
address varchar(100),
createtime datetime,
primary key(sellerid)
)engine=innodb default charset=utf8mb4;

create index idx_seller_name_sta_addr on tb_seller(name,status,address);

truncate tb_seller;
insert into tb_seller(sellerid,name,nickname,password,status,address,createtime) values
('huawei1',"华为技术有限公司1","华为小店1","c86cbf6cee7c11ea8be9f875a471a574",'0','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei2',"华为技术有限公司2","华为小店2","c86cbf6cee7c11ea8be9f875a471a574",'1','北京朝阳2号院','2088-01-01 12:00:00'),
('huawei3',"华为技术有限公司3","华为小店3","c86cbf6cee7c11ea8be9f875a471a574",'2','北京朝阳3号院','2088-01-01 12:00:00'),
('huawei4',"华为技术有限公司4","华为小店4","c86cbf6cee7c11ea8be9f875a471a574",'0','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei5',"华为技术有限公司5","华为小店5","c86cbf6cee7c11ea8be9f875a471a574",'1','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei6',"华为技术有限公司6","华为小店6","c86cbf6cee7c11ea8be9f875a471a574",'1','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei7',"华为技术有限公司7","华为小店7","c86cbf6cee7c11ea8be9f875a471a574",'2','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei8',"华为技术有限公司8","华为小店8","c86cbf6cee7c11ea8be9f875a471a574",'2','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei9',"华为技术有限公司9","华为小店9","c86cbf6cee7c11ea8be9f875a471a574",'0','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei10',"华为技术有限公司10","华为小店10","c86cbf6cee7c11ea8be9f875a471a574",'0','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei11',"华为技术有限公司11","华为小店11","c86cbf6cee7c11ea8be9f875a471a574",'0','北京朝阳1号院','2088-01-01 12:00:00'),
('huawei12',"华为技术有限公司12","华为小店12","c86cbf6cee7c11ea8be9f875a471a574",'0','北京朝阳1号院','2088-01-01 12:00:00')
;

```

#### 1.避免索引失效

##### 1.全值匹配

对索引中所有列都指定具体值，该情况下，索引生效，匹配效率高

```mysql
explain select * from tb_seller where name ="小米科技" and status='1' and address ='北京市';
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_seller
   partitions: NULL
         type: ref
possible_keys: idx_seller_name_sta_addr
          key: idx_seller_name_sta_addr
      key_len: 813
          ref: const,const,const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR:
No query specified
```

##### 2.最左前缀法则

如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。

如上面语句

```mysql
explain select * from tb_seller where name ="小米科技" and status='1' and address ='北京市'\G;
# 写成
explain select * from tb_seller where name ="小米科技" and status='1' \G;   # 没有跳过，就会走索引
# 写成
explain select * from tb_seller where address ='北京市'\G; # 就不行，查询条件中需要包含最左列
# 写成
explain select * from tb_seller where name ="小米科技" and address ='北京市'\G; # 只会走name的索引
```

这儿相当于爬楼梯，name为第一层，status相当于第二层，address相当于第三层，只有爬前一层之后才能爬后一层。

##### 3.范围查询右侧-索引失效

```mysql
# 此时只会走name和status的索引，不会走address的索引
explain select * from tb_seller where name ="小米科技" and status>'1' and address ='北京市'\G;  
```

##### 4.运算操作-索引失效

```mysql
explain select * from tb_seller where substring(name,3,2)='科技';
# 运算后，查询就不走索引了
```

![image-20210721164658996](..\_posts\images\image-20210721164658996.png)

##### 5.字符串须加单引号

```mysql
explain select * from tb_seller where name ="小米科技" and status>1\G; 
explain select * from tb_seller where name ="小米科技" and status>'1'\G; 
```

##### 6.避免`select *`

尽量使用覆盖索引（即索引完全包含查询列），减少使用`select *`

```mysql
explain select name from tb_seller where name='小米科技';
```

![image-20210721165825800](..\_posts\images\image-20210721165825800.png)

![image-20210721170434121](..\_posts\images\image-20210721170434121.png)

`using index` :使用覆盖索引的时候就会出现；

`using where`：在查找使用索引的情况下，需要回表查询所需的数据

`using index condition`：查找使用了索引，但是需要回表查询数据 **[回表查询效率低一些]**

`using index；using where`； 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据

##### 7.or分割的场景

or 前面的列有索引，后面的列没有索引，那么所有索引都不会被用到；

```mysql
explain select * from tb_seller where name ="小米科技" or nickname="小米官方旗舰店";
# 使用or，没有走索引
```

![image-20210721170838559](..\_posts\images\image-20210721170838559.png)

```mysql
# 改为and，就可以
explain select * from tb_seller where name ="小米科技" and nickname="小米官方旗舰店";
```

![image-20210721170938261](..\_posts\images\image-20210721170938261.png)

##### 8.模糊匹配like

```mysql
explain select * from tb_seller where name like "科技%";
# %在匹配词的后面，可以使用索引
```

![image-20210721171125418](..\_posts\images\image-20210721171125418.png)

```mysql
explain select * from tb_seller where name like "%科技";
# % 在匹配词的前面就不行，不走索引
```

![image-20210721171232944](..\_posts\images\image-20210721171232944.png)

```mysql
# 解决方法 -- 采用覆盖索引
explain select sellerid from tb_seller where name like "%科技";
```

![image-20210721171615207](..\_posts\images\image-20210721171615207.png)

##### 9.全表扫描vs索引

当mysql发现全表扫描比索引速度还要快的时候，就会自动选择全表扫描；

特别是在数据量大的表,该**类型数据少，Mysql就走索引**; 反之，数据类型多的时候就会走全表扫描；

##### 10.is NULL 和 is not NULL

有时走索引，有时不走索引，主要看null值得多少决定；

NULL少， is NULL走索引；		

NULL多，is not NULL走索引；   

```mysql
explain select * from tb_seller where address is not null;
```

![image-20210721172139565](..\_posts\images\image-20210721172139565.png)

##### 11.in 和 not in

in走索引，not in 不走索引，所以使用的时候尽量用in

```mysql
explain select * from tb_seller where sellerid in ('huawei1');
# 主键索引查询
```

![image-20210721173524052](..\_posts\images\image-20210721173524052.png)

##### 12.单列索引和复合索引

尽量使用复合索引

#### 2.查看索引使用情况

```mysql
show status like "科技%"
show global status like "科技%"
```

### 5.SQL优化

#### 1.大批量数据插入

对于InnoDB类型的表，有下列几种方式可以提高数据导入效率

1）主键顺序插入

```mysql
# 导入本地数据文件，设置分割符为逗号，行分隔符为换行符
load data local infile '/root/sql.log' into table 'tb_user_1' field terminated by ',' lines terminated by '\n';
```

实验证明，导入的数据为主键有序的数据，可以有效提高数据导入效率；

2）关闭唯一性校验

在导入的数据前执行`SET UNIQUE_CHECKS=0`,关闭唯一性校验；在数据导入结束后`SET UNIQUE_CHECKS=1`,恢复唯一性校验，可以提升导入效率。

```mysql
# 关闭唯一性校验
SET UNIQUE_CHECKS=0;
```

3）手动提交事务

导入数据前执行`SET AUTOCOMMIT=0;`,关闭自动提交，导入结束后再执行`SET AUTOCOMMIT=1;`打开自动提交，提升导入效率。

```mysql
# 手动提交设定
SET AUTOCOMMIT=0;
```



#### 2.优化insert语句

当进行数据的insert操作的时候，可以采用以下几种方式优化：

##### 1）合并提交

合并提交或者采用事务提交，可以避免多次`commit`,节省时间；

```mysql
insert into tb_test values (1,'Tom');
insert into tb_test values (2,'Jerry');
insert into tb_test values (3,'Cat');
# 可以优化为
insert into tb_test values (1,'Tom'),(2,'Jerry'),(3,'Cat');
# 或者在事务中提交
start transaction;
insert into tb_test values (1,'Tom');
insert into tb_test values (2,'Jerry');
insert into tb_test values (3,'Cat');
commit;
```

##### 2）数据有序插入

```mysql
#
insert into tb_test values (5,'Tom');
insert into tb_test values (2,'Jerry');
insert into tb_test values (4,'Cat');
insert into tb_test values (3,'Rose');
insert into tb_test values (1,'Tim');

# 可以优化为
insert into tb_test values (1,'Tim');
insert into tb_test values (2,'Jerry');
insert into tb_test values (3,'Rose');
insert into tb_test values (4,'Cat');
insert into tb_test values (5,'Tom');
```

优化后有序插入，提升数据导入的效率；

#### 3.优化orderby语句

##### 1）filesort排序

这种排序方式叫做文件排序，排序速度慢；

通过下面索引排序的方式，可以减少filesort的出现，但是在某些情况下，条件限制不能让filesort小时，那就需要加快filesort的排序操作。对于filesort，mysql有两种排序算法：

1）两次扫描算法：Mysql4.1之前，使用该方式排序。首先根据条件取出排序字段和行指针信息， 然后在排序区sort buffer中排序，如果sort buffer 不够，则在临时表temporary table中存储排序结果，完成排序之后，再根据行指针回表读取记录，该操作可能导致大量的随机I/O操作。

2）一次扫描算法：一次性取出满足条件的所有字段，然后再排序区sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法更高

Mysql通过比较系统变量max_length_for_sort_data的大小和Query语句取出的字段总大小，来判断使用哪种排序算法；

如果 max_length_sort_data>Query语句，使用一次扫描方法；反之使用两次扫描算法；**所以可以适当修改`max_length_sort_data`和`sort buffer`值来提升效率**。

![image-20210722195037619](..\_posts\images\image-20210722195037619.png)

##### 2）索引排序

```mysql
# 创建索引
create index idx_sal on emp(salary)，emp(age);
# 使用索引进行排序，返回字段只包含索引；这个就是沿用了覆盖索引的概念。
explain select salary from emp order by salary;
# 多字段排序时，同时采用升序或者降序，才能使用索引
# order by 后面的字段与索引的字段需要保持一致
explain select salary from emp order by salary desc ,age desc;
```

![image-20210722195656507](..\_posts\images\image-20210722195656507.png)

#### 4.优化group by语句

```mysql
# 一般用法
explain select age count(*) from emp group by age;
# 可以使用下面语句优化，去掉排序，提升效率
explain select age count(*) from emp group by age order by null;
# groupby支持所以，可以创建索引进行优化
```

![image-20210722201746203](..\_posts\images\image-20210722201746203.png)

#### 5.优化嵌套查询

嵌套查询就是子查询，查询效率不高；优化：采用多表联合查询来替换嵌套查询

```mysql
explain select * from t_user where id in (select user_id from user_role);
# 可以优化为
explain select * from t_user u,user_role ur where u.id=ur.user_id;
```

![image-20210722202126773](..\_posts\images\image-20210722202126773.png)

#### 6.优化or条件

对于包含or的查询子句，如果要利用索引，则or之间的每个条件列都必须使用索引，且不能使用复合索引；

如果没有索引，需要考虑增加索引。

![image-20210722202553685](..\_posts\images\image-20210722202553685.png)

```mysql
# 由于age没有索引，故不走索引查询
explain select * from emp where id =1 or age=30;

explain select salary from emp where id =1 or salary=3000;
# 建议使用union来替换or
explain select * from emp where id=1 union select * from emp where salary=3000;
```

![image-20210722202655181](..\_posts\images\image-20210722202655181.png)

![image-20210722202840774](..\_posts\images\image-20210722202840774.png)

![image-20210722203426152](..\_posts\images\image-20210722203426152.png)

type显示的是访问类型，是较为重要的指标，结果值从好到坏：

```
# 上面将type的时候提到过
NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_range > unique_subquery > index_subquery > range > index > all
```

比较可知，union要由于or；

#### 7.优化分页查询

```mysql
# 查询第200000条记录后的十条记录；mysql会检索前面的200000行，索引效率低
select * from tb_item limit 200000,10;
```

##### 1）优化思路1

在索引上实行排序分页操作,根据主键关联查找原表

```mysql
select id from tb_item order by id limit 200000,10;
# 使用下面的语句进行联合查询
select * from tb_item t,(select id from tb_item order by id limit 200000,10) a where t.id=a.id;
```

##### 2）优化思路2

该方法仅适用于主键自增的表，可以吧limit查询转换成定位

```mysql
select * from tb_item where id >200000 limit 10;
```

#### 8.使用SQL提示

SQL提示是优化数据库的一个重要手段，简单的说，就是在SQL语句中加入一些认为的提示来达到优化操作的目的

##### 1）use index

在查询语句中表名的后面，添加`use index`

单列索引和复合索引都存在的情况下，可以指定其走单列索引；

```mysql
# 仅仅是给mysql参考，mysql会自己根据自身需求走最省时的方式
select * from tb_seller use index(idx_seller_address) where address="北京市"
```

##### 2）ignore index

忽略走某个索引

##### 3）force index

这里就是强制了，不能任由mysql瞎走了



参考链接：https://www.bilibili.com/video/BV1CZ4y1M7MQ?t=181&p=94
