---
title: 数据库Mysql高级
layout: post
tags: 数据库
categories: ''
---

### 一、索引

参考地址：https://www.cnblogs.com/bypp/p/7755307.html

#### 1.什么是索引？

一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起**加速查询**，就不得不提到索引了。

#### 2.为什么要有索引呢？

索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能
非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。
索引优化应该是对查询性能优化最有效的手段了。**索引能够轻易将查询性能提高好几个数量级**。
索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。

#### 3.索引的原理

索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等

**本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

#### 4.磁盘IO与预读

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

#### 5.索引的数据结构

任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。

![img](..\_posts\images\1184802-20170912211249219-1576835998.png)

如上图，是一颗b+树，关于b+树的定义可以参见[B+树](http://zh.wikipedia.org/wiki/B%2B树)，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

\###b+树的查找过程
如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

#### 6.b+树性质

1**.索引字段要尽量的小**：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
2.**索引的最左匹配特性（即从左往右匹配）**：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

#### 7.Mysql索引管理

一、功能

```
#1. 索引的功能就是加速查找
#2. mysql中的primary key，unique等联合索引和唯一索引也都是索引，这些索引除了加速查找以外，还有约束的功能
```

二、MySQL的索引分类

```mysql
索引分类
1.普通索引index :加速查找
2.唯一索引
    主键索引：primary key ：加速查找+约束（不为空且唯一）
    唯一索引：unique：加速查找+约束 （唯一）
3.联合索引
    -primary key(id,name):联合主键索引
    -unique(id,name):联合唯一索引
    -index(id,name):联合普通索引
4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
5.空间索引spatial :了解就好，几乎不用
```

```mysql
 1 举个例子来说，比如你在为某商场做一个会员卡的系统。
 2 
 3 这个系统有一个会员表
 4 有下列字段：
 5 会员编号 INT
 6 会员姓名 VARCHAR(10)
 7 会员身份证号码 VARCHAR(18)
 8 会员电话 VARCHAR(10)
 9 会员住址 VARCHAR(50)
10 会员备注信息 TEXT
11 
12 那么这个 会员编号，作为主键，使用 PRIMARY
13 会员姓名 如果要建索引的话，那么就是普通的 INDEX
14 会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）
15 
16 #除此之外还有全文索引，即FULLTEXT
17 会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。
18 用于搜索很长一篇文章的时候，效果最好。
19 用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
20 但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。
21 
22 #其他的如空间索引SPATIAL，了解即可，几乎不用
```

三、索引两大类型 【hash索引和btree索引】

```mysql
#我们可以在创建上述索引的时候，为其指定索引类型，分两类
hash类型的索引：查询单条快，范围查询慢
btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

#不同的存储引擎支持的索引类型也不一样
InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；
```

四、创建和删除索引

```mysql
#  创建/删除索引的语法
#方法一：创建表时
    　　CREATE TABLE 表名 (
          字段名1  数据类型 [完整性约束条件…],
                 字段名2  数据类型 [完整性约束条件…],
                 [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
                 [索引名]  (字段名[(长度)]  [ASC |DESC]) 
                 );
 
 
 #方法二：CREATE在已存在的表上创建索引
         CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
                      ON 表名 (字段名[(长度)]  [ASC |DESC]) ;
 
 
 #方法三：ALTER TABLE在已存在的表上创建索引
         ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                              索引名 (字段名[(长度)]  [ASC |DESC]) ;
                              
 #删除索引：DROP INDEX 索引名 ON 表名字;

```

```mysql
善用帮助文档
help create
help create index
==================
1.创建索引
    -在创建表时就创建（需要注意的几点）
    create table s1(
    id int ,#可以在这加primary key
    #id int index #不可以这样加索引，因为index只是索引，没有约束一说，
    #不能像主键，还有唯一约束一样，在定义字段的时候加索引
    name char(20),
    age int,
    email varchar(30)
    #primary key(id) #也可以在这加
    index(id) #可以这样加
    );
    -在创建表后在创建
    create index name on s1(name); #添加普通索引
    create unique age on s1(age);添加唯一索引
    alter table s1 add primary key(id); #添加住建索引，也就是给id字段增加一个主键约束
    create index name on s1(id,name); #添加普通联合索引
2.删除索引
    drop index id on s1;
    drop index name on s1; #删除普通索引
    drop index age on s1; #删除唯一索引，就和普通索引一样，不用在index前加unique来删，直接就可以删了
    alter table s1 drop primary key; #删除主键(因为它添加的时候是按照alter来增加的，那么我们也用alter来删)
```

#### 8.测试索引

```mysql
#1. 准备表
create table s1(
id int,
name varchar(20),
gender char(6),
email varchar(50)
);

#2. 创建存储过程，实现批量插入记录
delimiter $$ #声明存储过程的结束符号为$$
create procedure auto_insert1()
BEGIN
    declare i int default 1;
    while(i<3000000)do
        insert into s1 values(i,concat('egon',i),'male',concat('egon',i,'@oldboy'));
        set i=i+1;
    end while;
END$$ #$$结束
delimiter ; #重新声明分号为结束符号

#3. 查看存储过程
show create procedure auto_insert1\G 

#4. 调用存储过程
call auto_insert1();
```

```mysql
#无索引：从头到尾扫描一遍，所以查询速度很慢
mysql> select * from s1 where id=333;
+------+---------+--------+----------------+
| id   | name    | gender | email          |
+------+---------+--------+----------------+
|  333 | egon333 | male   | 333@oldboy.com |
|  333 | egon333 | f      | alex333@oldboy |
|  333 | egon333 | f      | alex333@oldboy |
+------+---------+--------+----------------+
rows in set (0.32 sec)

mysql> select * from s1 where email='egon333@oldboy';
....
... rows in set (0.36 sec)
```

```mysql
#1. 一定是为搜索条件的字段创建索引，比如select * from t1 where age > 5;就需要为age加上索引

#2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，插入删除更新都很慢，只有查询快
比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。
建完以后，再查询就会很快了

#3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYI
```

![img](..\_posts\images\1184802-20170912214329375-1453229056.png)

#### 9.正确使用索引

一、覆盖索引

```mysql
#分析
select * from s1 where id=123;
该sql命中了索引，但未覆盖索引。
利用id=123到索引的数据结构中定位到该id在硬盘中的位置，或者说再数据表中的位置。
但是我们select的字段为*，除了id以外还需要其他字段，这就意味着，我们通过索引结构取到id还不够，
还需要利用该id再去找到该id所在行的其他字段值，这是需要时间的，很明显，如果我们只select id，
就减去了这份苦恼，如下
select id from s1 where id=123;
这条就是覆盖索引了，命中索引，且从索引的数据结构直接就取到了id在硬盘的地址，速度很快
```

![img](..\_posts\images\1184802-20170912214643547-1094772770.png)

二、联合索引

![img](..\_posts\images\1184802-20170912214652782-1000358771.png)

三、索引合并

```mysql
#索引合并：把多个单列索引合并使用

#分析：
组合索引能做到的事情，我们都可以用索引合并去解决，比如
create index ne on s1(name,email);#组合索引
我们完全可以单独为name和email创建索引

组合索引可以命中：
select * from s1 where name='egon' ;
select * from s1 where name='egon' and email='adf';

索引合并可以命中：
select * from s1 where name='egon' ;
select * from s1 where email='adf';
select * from s1 where name='egon' and email='adf';

乍一看好像索引合并更好了：可以命中更多的情况，但其实要分情况去看，如果是name='egon' and email='adf',
那么组合索引的效率要高于索引合并，如果是单条件查，那么还是用索引合并比较合理
```

![img](..\_posts\images\1184802-20170912215426922-1260754280.png)

#### 10.索引快速化规则

```mysql
#1.最左前缀匹配原则，非常重要的原则，
create index ix_name_email on s1(name,email,)
- 最左前缀匹配：必须按照从左到右的顺序匹配
select * from s1 where name='egon'; #可以
select * from s1 where name='egon' and email='asdf'; #可以
select * from s1 where email='alex@oldboy.com'; #不可以
mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，
d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

#2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器
会帮你优化成索引可以识别的形式

#3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，
表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、
性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，
这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

#4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’
就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，
但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。
所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
```

```mysql
mysql> select * from s1 where id>3 and name='egon' and email='alex333@oldboy.com' and gender='male';
Empty set (0.39 sec)

mysql> create index idx on s1(id,name,email,gender); #未遵循最左前缀
Query OK, 0 rows affected (15.27 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> select * from s1 where id>3 and name='egon' and email='alex333@oldboy.com' and gender='male';
Empty set (0.43 sec)


mysql> drop index idx on s1;
Query OK, 0 rows affected (0.16 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> create index idx on s1(name,email,gender,id); #遵循最左前缀
Query OK, 0 rows affected (15.97 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> select * from s1 where id>3 and name='egon' and email='alex333@oldboy.com' and gender='male';
Empty set (0.03 sec)
```

```mysql
1 6. 最左前缀匹配
 2 index(id,age,email,name)
 3 #条件中一定要出现id(只要出现id就会提升速度)
 4 id
 5 id age
 6 id email
 7 id name
 8 
 9 email #不行  如果单独这个开头就不能提升速度了
10 mysql> select count(*) from s1 where id=3000;
11 +----------+
12 | count(*) |
13 +----------+
14 |        1 |
15 +----------+
16 1 row in set (0.11 sec)
17 
18 mysql> create index xxx on s1(id,name,age,email);
19 Query OK, 0 rows affected (6.44 sec)
20 Records: 0  Duplicates: 0  Warnings: 0
21 
22 mysql>  select count(*) from s1 where id=3000;
23 +----------+
24 | count(*) |
25 +----------+
26 |        1 |
27 +----------+
28 1 row in set (0.00 sec)
29 
30 mysql>  select count(*) from s1 where name='egon';
31 +----------+
32 | count(*) |
33 +----------+
34 |   299999 |
35 +----------+
36 1 row in set (0.16 sec)
37 
38 mysql>  select count(*) from s1 where email='egon3333@oldboy.com';
39 +----------+
40 | count(*) |
41 +----------+
42 |        1 |
43 +----------+
44 1 row in set (0.15 sec)
45 
46 mysql>  select count(*) from s1 where id=1000 and email='egon3333@oldboy.com';
47 +----------+
48 | count(*) |
49 +----------+
50 |        0 |
51 +----------+
52 1 row in set (0.00 sec)
53 
54 mysql>  select count(*) from s1 where email='egon3333@oldboy.com' and id=3000;
55 +----------+
56 | count(*) |
57 +----------+
58 |        0 |
59 +----------+
60 1 row in set (0.00 sec)

建联合索引，最左匹配
```

**索引无法命中的情况需要注意：**

```mysql
- like '%xx'
    select * from tb1 where email like '%cn';
    
    
- 使用函数
    select * from tb1 where reverse(email) = 'wupeiqi';
    
    
- or
    select * from tb1 where nid = 1 or name = 'seven@live.com';
    
    
    特别的：当or条件中有未建立索引的列才失效，以下会走索引
            select * from tb1 where nid = 1 or name = 'seven';
            select * from tb1 where nid = 1 or name = 'seven@live.com' and email = 'alex'
            
            
- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select * from tb1 where email = 999;
    
普通索引的不等于不会走索引
- !=
    select * from tb1 where email != 'alex'
    
    特别的：如果是主键，则还是会走索引
        select * from tb1 where nid != 123
- >
    select * from tb1 where email > 'alex'
    
    
    特别的：如果是主键或索引是整数类型，则还是会走索引
        select * from tb1 where nid > 123
        select * from tb1 where num > 123
        
        
#排序条件为索引，则select字段必须也是索引字段，否则无法命中
- order by
    select name from s1 order by email desc;
    当根据索引排序时候，select查询的字段如果不是索引，则不走索引
    select email from s1 order by email desc;
    特别的：如果对主键排序，则还是走索引：
        select * from tb1 order by nid desc;
 
- 组合索引最左前缀
    如果组合索引为：(name,email)
    name and email       -- 使用索引
    name                 -- 使用索引
    email                -- 不使用索引


- count(1)或count(列)代替count(*)在mysql中没有差别了

- create index xxxx  on tb(title(19)) #text类型，必须制定长度
```

```mysql
- 避免使用select *
- count(1)或count(列) 代替 count(*)
- 创建表时尽量时 char 代替 varchar
- 表的字段顺序固定长度的字段优先
- 组合索引代替多个单列索引（经常使用多个条件查询时）
- 尽量使用短索引
- 使用连接（JOIN）来代替子查询(Sub-Queries)
- 连表时注意条件类型需一致
- 索引散列值（重复少）不适合建索引，例：性别不适合
```

![img](..\_posts\images\1184802-20170912233709188-557973567.png)

#### 11.**慢查询优化的基本步骤**

```mysql
0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3.order by limit 形式的sql语句让排序的表优先查
4.了解业务方使用场景
5.加索引时参照建索引的几大原则
6.观察结果，不符合预期继续从0分析
```

参考链接：https://www.cnblogs.com/bypp/p/7755307.html

### 二、视图

​		视图是保存在数据库中得SELECT查询，因此对于查询执行的大多数操作也可在视图上进行。

​		为了简化复杂SQL语句编写，以及提高数据库安全性，MySQL数据库视图特性。视图是一张虚拟表，不在数据库中以储存的数据值形式存在。在开发中，开发者往往只对某些特定数据和所负责的特定任务感兴趣,只需要看到这一部分数据即可。这时候就可以用到视图来完成。

#### 1.用途

1. 处于安全考虑，用户不必看到整个数据库的结构，用来隐藏部分数据
2. 符合用户日常业务逻辑，使用户更容易理解数据

#### 2.为什么需要视图

​		实际工作中，不同身份的用户所关注的数据库数据可能不一样。如：企业员工信息表中保存该企业所有员工的信息，不同职位的人员对该表中查询的数据范围可能不同。根据人力资源制度的规定：

​	企业老板 ---  所有员工的信息

​	人力主管 --- 全体员工的薪酬、岗位和绩效

​	企业出纳 --- 仅能查看员工的薪酬

​	企业员工 --- 仅能查看本人记录

#### 3.什么是视图

​	数据库中的视图是一个虚拟表，但它同真实表一样，包含一系列带有名称的行和列数据。行和列数据来自由定义视图查询所引用的表，并且在应用视图时动态生成。另外，视图还可以在已经存在的视图的基础上定义。

　　视图一经定义变存储在数据库中，与其相对应的数据并没有像表那样在数据库中再存储一份，通过视图看到的数据只是存储在基本表中的数据。对视图的操作与对表的操作一样，可以对其进行查询、修改和删除。**当对通过视图看到的数据进行修改时，相应的基本表中的数据也会发生变化；**同时，**若是基本表的数据发生变化，则这种变化也会自动地反映在视图上**。

#### 4.创建视图

```mysql
# 语法
CREATE [OR REPLACE] [{FORCE|NOFORCE}] VIEW view_name
AS
SELECT查询
[WITH READ ONLY CONSTRAINT]

# 语法解析：
1. OR REPLACE：如果视图已经存在，则替换旧视图。
2. FORCE：即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用。
3. NOFORCE：如果基表不存在，无法创建视图，该项是默认选项。
4. WITH READ ONLY：默认可以通过视图对基表执行增删改操作，但是有很多在基表上的限制(比如：基表中某列不能为空，但是该列没有出现在视图中，则不能通过视图执行insert操作)，WITH READ ONLY说明视图是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作。
```

```MYSQL
# 创建一个部门的表和一个员工的表：
# 部门表：
DROP TABLE IF EXISTS `department`;
CREATE TABLE `department` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `departmentName` varchar(255) DEFAULT NULL,
  `departmentID` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
-- ----------------------------
INSERT INTO `department` VALUES ('1', '开发部', '201');
INSERT INTO `department` VALUES ('2', '技术部', '202');
INSERT INTO `department` VALUES ('3', '测试部', '203');

# 员工表：
DROP TABLE IF EXISTS `employee`;
CREATE TABLE `employee` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `lastName` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `departmentID` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
INSERT INTO `employee` VALUES ('1', '亚索', '123qq.com', '201');
INSERT INTO `employee` VALUES ('2', '李青', '12345@qq.com', '201');
INSERT INTO `employee` VALUES ('3', '剑圣', '2354@qq.com', '202');
INSERT INTO `employee` VALUES ('4', '嘉文', '6565@qq.com', '203');
```

查询数据

```mysql
select e.*,d.departmentName from employee e,department d where e.departmentID = d.departmentID;
```

<img src="D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210718143939425.png" alt="image-20210718143939425" style="zoom: 80%;" />

为以上结果创建视图

```mysql
create view VIEW_emp_dep as select e.*,d.departmentName from employee e,department d where e.departmentID = d.departmentID;
```

![image-20210718144110810](..\_posts\images\image-20210718144110810.png)

#### 5.查询视图

```mysql
select * from view_emp_dep;
```

<img src="..\_posts\images\image-20210718144226516.png" alt="image-20210718144226516" style="zoom:80%;" />

```mysql
# show tables 可以查看所有的表和视图
show tables
show table status LIKE 'view_emp_dep';
```

<img src="..\_posts\images\image-20210718145126403.png" alt="image-20210718145126403" style="zoom:80%;" />

#### 6.更新视图

```mysql
# 将皇子改成德玛
update view_emp_dep set lastName='德玛西亚' where departmentID=203;
select * from view_emp_dep
```

<img src="..\_posts\images\image-20210718144421379.png" alt="image-20210718144421379" style="zoom:80%;" />

此时原表中数据也发生变化：

<img src="..\_posts\images\image-20210718144601438.png" alt="image-20210718144601438" style="zoom:50%;" />

#### 7.修改视图

```mysql
# 语法
alter [algorithm]={undefined|merge|temptable}
view view_name[(col_list)]
as select_statement
[with[cascaded|local|check option]]

with[cascaded|local|check option]决定了是否允许更新数据使记录不再满足视图的条件
local：只要满足本视图的条件就可以更新
cascaded：必须满足所有针对该视图的所有视图的条件才可以更新
```

```mysql
# 修改视图内容
alter view view_emp_dep as select e.lastName,d.departmentName from employee e,department d where e.departmentID = d.departmentID;
select * from view_emp_dep;
```

<img src="..\_posts\images\image-20210718144937265.png" alt="image-20210718144937265" style="zoom:80%;" />

#### 8.删除视图

```mysql
# 语法
drop view [if exists]viewname[,viewname]...[restrict|cascade]
```

```mysql
drop view view_emp_dep;
show tables;
```

#### 9.场景用法

视图通常用来进行下面三种操作：

* 筛选表中的行
* 防止未经许可的用户访问敏感信息
* 将多个物理数据表抽象成一个逻辑数据表

视图的优势：

1. 对最终用户

   结果更容易理解。创建视图时，可以将列名改为有意义的名称，使用户更容易理解所代表的内容。**在视图中修改列名不会影响基表中得列名**。

   获取数据更容易。很多人对SQL不太了解，因此对于他们来说，创建多个表的复杂查询很困难，可以通过创建视图方便用户访问多个表中的数据。

2. 对开发者的好处

   限制数据检索更容易。开发人员有时需要隐藏某些行或列的数据信息，通过视图可以使用户更加灵活的访问他们所需要的数据并保证表数据的安全性。

   维护应用程序更加方便。调试视图比调试查询更容易，跟踪视图中各个步骤的错误更为容易，这是因为所有的步骤都是视图的组成部分。

视图命名

*  在SQL命名规范中，视图一般以view_xxx或v_xxx的样式来命名。

* 与创建数据表相同，在创建视图之前，如果数据库中有同名视图，需要先删除后创建，

  ```mysql
  DROP VIEW IF EXISTS view_emp_dep
  CREATE VIEW view_emp_dep AS SELECT e.lastName,d.departmentName from employee e,department d where e.departmentID = d.departmentID;
  ```

视图使命

​	从一个或多个表或视图中到处的虚拟表，其结构和数据是建立在对表的查询的基础上。理论上，视图可以像普通的物理表一样使用，进行增加、删除、修改和查询等。其中修改视图的数据实际是对原始数据表进行修改，这种用法修改数据库会有很多限制，所以**在实际开发中，视图仅做查询**。

视图/表区分

​	在Mysql数据库安装成功后，会自动创建系统数据库information_schema,在该数据库中包含视图信息的表views，可以通过views来查看所有视图相关的信息。

```mysql
USE information_schema;
SELECT * FROM views\G;
SELECT * FROM views where TABLE_NAME='view_emp_dep'\G;
```

### 三、事务

#### 1.用途

​	事务（Transaction）是将一系列数据操作捆绑成为一个整体进行统一管理。

​	如果某一事务执行成功，则该事务中进行的所有数据更改均会提交，成为数据库中得永久部分。

​	如果事务执行中途失败，则数据原数据不会被改变。

#### 2.为什么需要事务

​	在银行业务中，有一条记账原则，即有借有贷、借贷相等。为了保证这个原则，每发生一笔业务， 就需要在借方科目和贷方科目上至少各记上一笔，并且者两笔账要么同时成功、要么同时失败。如果一方成功一方失败，那么就会造成记错账的问题。

​	如：

```mysql
 # 初始状态：
 张三 --- ￥1000； 李四￥1
 # 需要实现
 转账 张三---->500--->李四，实现过程
 # 实现过程
 张三：1000-500 =500 ;   # 此时发生机器故障，无法执行下一过程，那么就会出现 张三 ：￥500，李四：￥501
 李四：1 + 500 = 500 ；
 # 此时就会出现记错账的问题
```

​		事务的出现完美的解决了上述问题，事务是一种机制、一个操作序列，包含了一组数据库操作命令，并且把所有的命令作为一个整体一起向系统提交或撤销操作的请求，即这一组命令要么都执行，要么都不执行。因此事务是一个不可分割的工作逻辑单元，在数据库系统上执行并发操作时，事务是作为最小的控制单元来使用的，特别适用于多用户同时操作的数据库系统。如：银行、保险公司以及证券交易系统等。

事务的属性（**ACID**）：

* 原子性【**Automicity**】：事务是一个完整的操作，各元素是不可分割的（原子）。
* 一致性【**Consistency**】：当事务完成时，数据必须处于一致状态。事务执行过程中，可能出现不一致情况，如银行一个账户余额减少、另一个账户还未修改；但是事务完成就会重新回到一致状态。
* 隔离性【**Isolation**】：对数据的修改的所有并发事务都是隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或者影响其他事务。另外，当其他进程正在同时使用相同的数据进行事务操作时，则直到该事务成功提交以后，对数据的修改才会生效。【这个后面隔离性着重讲】
* 持久性【**Durability**】：事务的持久性指不管系统是否发生故障，事务处理的结果都是永久的；即一旦事务被提交，事务的效果会永久保存到数据库中。

#### 3.事务控制语句

```mysql
BEGIN 或 START TRANSACTION 显式地开启一个事务；

COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；

ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；

SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；

RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；

ROLLBACK TO identifier 把事务回滚到标记点；

SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。
```

MYSQL 事务处理主要有两种方法：

1、用 BEGIN, ROLLBACK, COMMIT来实现

```mysql
BEGIN		开始一个事务
ROLLBACK	事务回滚
COMMIT 		事务确认
```

```mysql
mysql> start transaction;#手动开启事务
mysql> insert into t_user(name) values('pp');
mysql> commit;#commit之后即可改变底层数据库数据
mysql> select * from t_user;
+----+------+
| id | name |
+----+------+
|  1 | jay  |
|  2 | man  |
|  3 | pp   |
+----+------+
3 rows in set (0.00 sec)
```

```mysql
mysql> start transaction;
mysql> insert into t_user(name) values('yy');
mysql> rollback;								# 回滚操作，事务操作取消，数据不发生更改
mysql> select * from t_user;
+----+------+
| id | name |
+----+------+
|  1 | jay  |
|  2 | man  |
|  3 | pp   |
+----+------+
3 rows in set (0.00 sec)
```

2、直接用 SET 来改变 MySQL 的自动提交模式:

```mysql
SET AUTOCOMMIT=0 	禁止自动提交
SET AUTOCOMMIT=1 	开启自动提交
```

#### 4.事务特性--隔离性

隔离性有隔离级别(4个)

```tex
 （1）读未提交：read uncommitted
 （2）读已提交：read committed
 （3）可重复读：repeatable read
 （4）可串行化：serializable
```

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | √    | √          | √    |
| Read committed   | ×    | √          | √    |
| Repeatable read  | ×    | ×          | √    |
| Serializable     | ×    | ×          | ×    |

- 脏读：指一个线程中的事务读取到了另外一个线程中未提交的数据。
- 不可重复读（虚读）：指一个线程中的事务读取到了另外一个线程中提交的update的数据。
- 幻读：指一个线程中的事务读取到了另外一个线程中提交的insert的数据

##### 读未提交

- 事物A和事物B，事物A未提交的数据，事物B可以读取到
- 这里读取到的数据叫做“脏数据”
- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别

公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。

<img src="..\_posts\images\webp" alt="img" style="zoom:150%;" />

出现上述情况，即我们所说的脏读 ，两个并发的事务：

```
“事务A：领导给singo发工资”、“事务B：singo查询工资账户”
```

事务B读取了事务A尚未提交的数据。

##### 读已提交

- 事务A和事物B，事务A提交的数据，事务B才能读取到
- 这种隔离级别高于读未提交
- 换句话说，对方事务提交之后的数据，我当前事务才能读取到
- 这种级别可以避免“脏数据”
- 这种隔离级别会导致“不可重复读取”
- Oracle默认隔离级别

singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务。当singo消费完去扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何......

出现上述情况，即我们所说的不可重复读 ，两个并发的事务：

```
“事务A：singo消费”、“事务B：singo的老婆网上转账”
```

事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。

当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读。

大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。

##### 可重复读

- 事务A和事务B，事务A提交之后的数据，事务B读取不到
- 事务B是可重复读取数据
- 这种隔离级别高于读已提交
- 换句话说，对方提交之后的数据，我还是读取不到
- 这种隔离级别可以避免“不可重复读取”，达到可重复读取
- 比如1点和2点读到数据是同一个
- MySQL默认级别
- 虽然可以达到可重复读取，但是会导致“幻像读”

当隔离级别设置为Repeatable read 时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。

虽然Repeatable read避免了不可重复读，但还有可能出现幻读 。

singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction ... ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。

##### 串行化

- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发



作者：王王王王王景
链接：https://www.jianshu.com/p/081a3e208e32
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：王王王王王景
链接：https://www.jianshu.com/p/081a3e208e32
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：王王王王王景
链接：https://www.jianshu.com/p/081a3e208e32
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。









作者：王王王王王景
链接：https://www.jianshu.com/p/081a3e208e32
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


链接：https://www.jianshu.com/p/081a3e208e32

#### 四、存储过程与存储函数

#### 五、触发器

