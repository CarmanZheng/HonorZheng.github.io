---
title: Flask蓝图
layout: post
tags: Flask
categories: ''

---

### Flask蓝图

参考链接： https://www.jianshu.com/p/7c474ee9ffee

### 1. 模块化

随着flask程序越来越复杂,我们需要对程序进行模块化的处理,之前学习过python的模块化管理,于是针对一个简单的flask程序进行模块化处理

简单来说，Blueprint 是一个存储视图方法的容器，这些操作在这个Blueprint 被注册到一个应用之后就可以被调用，Flask 可以通过Blueprint来组织URL以及处理请求。

Flask使用Blueprint让应用实现模块化，在Flask中，Blueprint具有如下属性：

- 一个项目可以具有多个Blueprint
- 可以将一个Blueprint注册到任何一个未使用的URL下比如 “/”、“/sample”或者子域名
- 在一个应用中，一个模块可以注册多次
- Blueprint可以单独具有自己的模板、静态文件或者其它的通用操作方法，它并不是必须要实现应用的视图和函数的
- 在一个应用初始化时，就应该要注册需要使用的Blueprint

但是，**一个Blueprint并不是一个完整的应用，它不能独立于应用运行，而必须要注册到某一个应用中。**

使用蓝图可以分为四个步骤

1. 创建一个蓝图的包,例如**users**,并在`__init__.py`文件中创建蓝图对象，即在一个**包（带有__init__的文件夹）**中创建。

```python
users=Blueprint('users',__name__)
```

1. 在这个蓝图目录下, 创建**views.py**文件,保存当前蓝图使用的视图函数

```python
@admin.route('/')
def home():
    return 'user.home'
```

1. 在**users/\**init\**.py**中引入views.py中所有的视图函数

```python
from flask import Blueprint
# 等同于原来在 manage.py里面的 app = Flask()
users=Blueprint('users',__name__)

from .views import *
```

1. 在主应用main.py文件中的app对象上注册这个**users**蓝图对象

```python
from users import users
app.register_blueprint(users,url_prefix='/users')
```

当这个应用启动后,通过/users/可以访问到蓝图中定义的视图函数

### 2.运行机制

- 蓝图是保存了一组将来可以在应用对象上执行的操作，注册路由就是一种操作
- 当在app对象上调用 route 装饰器注册路由时,这个操作将修改对象的url_map路由表
- 然而，蓝图对象根本没有路由表，当我们在蓝图对象上调用route装饰器注册路由时,它只是在内部的一个延迟操作记录列表defered_functions中添加了一个项
- 当执行app对象的 register_blueprint() 方法时，应用对象将从蓝图对象的 defered_functions 列表中取出每一项，并以自身作为参数执行该匿名函数，即调用应用对象的 add_url_rule() 方法，这将真正的修改应用对象的usr_map路由表

### 3.蓝图的url前缀

- 当我们在应用对象上注册一个蓝图时，可以指定一个url_prefix关键字参数（这个参数默认是/）

![img](https:////upload-images.jianshu.io/upload_images/16925711-25b176dba1535f6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image.png

- 在应用最终的路由表 url_map中，在蓝图上注册的路由URL自动被加上了这个前缀，这个可以保证在多个蓝图中使用相同的URL规则而不会最终引起冲突，只要在注册蓝图时将不同的蓝图挂接到不同的自路径即可
- url_for在使用时，如果要生成一个蓝图里面的视图对应的路由地址，则需要声明当前蓝图名称+视图名称



```python
url_for('users.home') # /users/home
```

### 4.注册蓝图中的静态文件的相关路由

和应用对象不同，蓝图对象创建时不会默认注册静态目录的路由。需要我们在 创建时指定 static_folder 参数。

下面的示例将蓝图所在目录下的static_users目录设置为静态目录

```python
# users/__init__.py，代码：
user_blu = Blueprint("users",__name__,static_folder='static_users')

# 启动文件 main.py，代码：
from users import user_blu
app.register_blueprint(user_blu,url_prefix='/users')
```

现在就可以使用/admin/static_admin/ 访问static_admin目录下的静态文件了 定制静态目录URL规则 ：可以在创建蓝图对象时使用 static_url_path 来改变静态目录的路由。

![img](https:////upload-images.jianshu.io/upload_images/16925711-6e74decf3c6c45aa.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image.png

下面的示例将为 static_admin 文件夹的路由设置为 /lib

```python
admin = Blueprint("admin",__name__,static_folder='static_admin',static_url_path='/lib')
app.register_blueprint(admin,url_prefix='/admin')
```

### 5.设置蓝图中模版的目录

蓝图对象默认的模板目录为系统的模版目录，可以在创建蓝图对象时使用 template_folder 关键字参数设置模板目录

创建蓝图中的模板目录template_users :

![img](https:////upload-images.jianshu.io/upload_images/16925711-e54e6d23bb2937cf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image.png



```python
admin = Blueprint('admin',__name__,template_folder='templates_users')
```

![img](https:////upload-images.jianshu.io/upload_images/16925711-b0549607dcd16fa3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image.png

注:如果在 templates 中存在和 templates_users 有同名模板文件时, 则系统会优先使用 templates 中的文件

# 调整session配置

分析SQLAlachemy的构造方式可以发现，初始化并非一定要传递app应用对象到内部，事实上它提供了init_app方法给我们后续调用。而 init_app 方法是flask框架要求任何的第三方组件都要实现这个方法。

init_app方法内部就是要第三方组件开发者编写一些使用当前组建的默认配置项以及把当前组件设置成一个对象，加载到app对象内部extensions字典才能让开发者在flask框架内部配置和使用当前组件。

我们可以利用这种组件开发机制，那么把配置代码抽离出去。

配置文件中：



```python
import redis
from flask_sqlalchemy import SQLAlchemy
# 创建db对象
db = SQLAlchemy()
class Config(object):
    DEBUG = True
    SECRET_KEY = "*(%#4sxcz(^(#$#8423"
    # 数据库链接配置:
    #数据类型://登录账号:登录密码@数据库主机IP:数据库访问端口/数据库名称
    SQLALCHEMY_DATABASE_URI = "mysql://root:123@127.0.0.1:3306/flask_students"
    # 设置mysql的错误跟踪信息显示
    SQLALCHEMY_TRACK_MODIFICATIONS = True
    # 打印每次模型操作对应的SQL语句
    SQLALCHEMY_ECHO = True

    """把session保存到redis中"""
    # session存储方式为redis
    # SESSION_TYPE="redis"
    # # 如果设置session的生命周期是否是会话期, 为True，则关闭浏览器session就失效
    # SESSION_PERMANENT = False
    # # 是否对发送到浏览器上session的cookie值进行加密
    # SESSION_USE_SIGNER = False
    # # 保存到redis的session数的名称前缀
    # SESSION_KEY_PREFIX = "session:"
    # # session保存数据到redis时启用的链接对象
    # SESSION_REDIS = redis.Redis(host='127.0.0.1', port='6379')  # 用于连接redis的配置

    SESSION_TYPE= 'sqlalchemy'  # session的存储方式为sqlalchemy
    SESSION_SQLALCHEMY= db  # SQLAlchemy对象
    SESSION_SQLALCHEMY_TABLE= 'sessions'  # session要保存的表名称
    SESSION_PERMANENT= True  # 如果设置为True，则关闭浏览器session就失效。
    SESSION_USE_SIGNER= False  # 是否对发送到浏览器上session的cookie值进行加密
    SESSION_KEY_PREFIX= 'session:'  # 保存到session中的值的前缀
```

启动文件main.py，代码：

```python
from flask import Flask
from config import Config,db
from flask_session import Session

from flask import session

app = Flask(__name__,template_folder='templates')
app.config.from_object(Config)

# 把app加载到db对象中
db.init_app(app)

Session(app)

@app.route("/")
def index():
    return "ok"

@app.route("/set_session")
def set_session():
    """设置session"""
    session["username"] = "小明"
    return "ok"

if __name__ == '__main__':
    # db.create_all()
    print( app.url_map )
    app.run()
```



作者：Gavininn
链接：https://www.jianshu.com/p/7c474ee9ffee
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。