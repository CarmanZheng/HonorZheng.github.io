---
title: Vue1
layout: post
tags: 前端
categories: ''
---

## 一、认识vue

​		vue是一个渐进式的矿建，，渐进式意味着可以**将vue作为你应用的一部分嵌入其中**，带来丰富的交互体验。

### vue特点

1. 解耦视图和数据
2. 可复用的组件
3. 前端路由技术
4. 状态管理
5. 虚拟DOM

## 二、安装

1. 直接cdn引入

   开发环境和生产环境两个版本

   ```
   <!-- 开发环境版本，包含了有帮助的命令行警告 -->
   <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
   ```

   或者：

   ```
   <!-- 生产环境版本，优化了尺寸和速度 -->
   <script src="https://cdn.jsdelivr.net/npm/vue"></script>
   ```

2. 下载s和引入

3. npm安装

   后续通过webpack和CLI进行安装

## 三、MVVM结构

**view层**

​	视图层，在前端中，通常就是DOM层，主要用于给客户展示各种信息

**model层**

​	数据层，数据可能是我们固定的死数据，更多的是来自我们服务器，从网络请求的数据

**ViewModel层**

​	视图模型层，是model和view沟通的桥梁；

​	一方面实现Data Binding，即数据绑定，将model的改变实时的反应到view中；

​	另一方面她实现DOM Listener，也就是DOM监听，当DOM发生一些事件[点击、滚动、touch等]时，可以监听到，并在需要的情况下改变对应的Data

## 四、生命周期

## 五、计算属性和methods属性

conputed 可以节省计算次数，推荐使用computed计算属性； methods计算次数较多。

## 六、let 和 var

```
var 的设计可以看成是JavaScript语言设计上的错误，但是这种错误多半是不能修复和移出，以后需要向后兼容

后来，JavaScript作者Brendan Eich就决定修复这个问题，于是他增加了一个新的关键字：let

我们可以将let看成更加完美的var。
```

### 块级作用域

var没有块级作用域，let有块级作用域

## 七、const的使用

在很多语言中已经存在，比如C、C++中，主要的作用是将某个变量修饰为常量；

1. 在JavaScript中也是如此，使用const修饰的标识符不能被二次赋值
2. 在定义的时候必须赋值
3. 常量的含义是指向的对象不能修改，但是可以修改对象内部的属性

## 八、v-on的参数

1. 事件定义的时候，写方法时省略了小括号，但是方法本身是需要一个参数的，这个是时候，VUE会默认将浏览器产生的**event事件对象**作为参数传递到方法。

   ```
   @click = 'btn2Click'	
   ```

2. 通过$event 可以获得浏览器产生的event

```
@click = "btn3Click(abc,$event)"
```

3. v-on修饰符

   参考https://blog.csdn.net/sleepwalker_1992/article/details/82903246

```
v-on 事件修饰符
常用的事件修饰符有：

.stop  阻止事件冒泡
.self  当事件在该元素本身触发时才触发事件

.capture 添加事件侦听器是，使用事件捕获模式

.prevent  阻止默认事件

.once 事件只触发一次
```

```
v-on 按键修饰符
Vue 允许为 v-on 在监听键盘事件时添加按键修饰符

按键别名：
    .enter
    .tab
    .delete (捕获 "删除" 和 "退格" 键)
    .esc
    .space
    .up
    .down
    .left
    .right
    .ctrl
    .alt
    .shift
    .meta

注意：在Windows系统键盘上meta对应windows徽标键(⊞)。
```

## 九、filter，map，reduce

这几个函数的用法与python中的相同

```javascript
const nums = [10,20,111,222,444,40,50]
let total = nums.filter(n => n<100).map(n=> n*2).reduce((pre,n)=>pre+n)
console.log(total)
```

## 十、 v-model双向绑定

1. v-bind绑定一个value属性
2. v-on指令给当前的元素绑定input事件

```html
<input type = 'text' v-model='message'>
等同于
<input type = 'text' v-bind:value = 'message' v-on:input="message = $event.target.value"
```

修饰符

```vue
v-model.lazy  让数据失去焦点时或者敲回车，才实现绑定

v-model.number 将字符串转化为数字

v-model.trim  去除输入的空格
```

## 十一、组件化

### 1. 组件化模块化开发

开发步骤：

1. 创建组件构造器

   vue.extend() : 调用Vue.extend()创建的是一个组件构造器；

   通常在创建组件构造器时，传入template代表我们自定义组件的模板；

   该模板就是使用到组件的地方，要显示的HTML代码

   现在基本不用这个写法了，直接使用下面的Vue.component()创建

   

2. 注册组件

   ```html
   <template id="cpn">
   			<!-- 注意，这个地方需要用div包起来 -->
   			<div>
   				<h2>
   					当前计数为{{counter}}
   				</h2>
   				<button type="button" @click="decrement"> - </button>
   				<button type="button" @click="increment"> + </button>
   			</div>
   </template>
   <script>
   		Vue.component('cpn', {
   			template: "#cpn",
   			data() {
   				return {
   					counter: 0
   				}
   			},
   			methods: {
   				increment() {
   					this.counter++
   				},
   				decrement() {
   					this.counter--
   				}
   			}
   		})
   
   		const app = new Vue({
   			el: '#app',
   		})
   	</script>
   ```

   vue.component()

   用来注册组件，需要传入两个参数：1.注册组件的标签名 2. 组件构造器

   注意：组件创建时，data为函数，防止复用时候的干扰

3. 使用组件

### 2. 父子通信

​	父传子 props

​	字传父 $emit 

​		$emit('事件名'，变量值)

![image-20210416140056934](D:\04_Tianchi\Tianchi_task\HonorZheng.github.io\_posts\images\image-20210416140056934.png)

## 十二、插槽 slot

在组件中定义slot，后面可以直接写入替换，实现组件复用，提升扩展性能

### 1. 匿名插槽

替换掉整个slot单元

### 2. 具名插槽

通过name属性进行命名

```js
// 组件
Vue.component('lv-hello', {
  template: `
    <div>
      <slot name="header"></slot>
      <h1>我的天呀</h1>
    </div>
  `
})
```

```html
<div id="app">
  <!-- 老版本使用具名插槽 -->
  <lv-hello>
    <p slot="header">我是头部</p>
  </lv-hello>
  <!-- 新版本使用具名插槽 -->
  <lv-hello>
    <!-- 注意：这块的 v-slot 指令只能写在 template 标签上面，而不能放置到 p 标签上 -->
    <template v-slot:header>
      <p>我是头部</p>
    </template>
  </lv-hello>
</div>
```

> 将 `v-slot:` 替换成 `#` 号

```html
<div id="app">
  <lv-hello>
    <template #header>
      <p>我是头部</p>
    </template>
    <!-- 注意: #号后面必须有参数，否则会报错。即便是默认插槽，也需要写成 #default -->
    <template #default>
      <p>我是默认插槽</p>
    </template>
  </lv-hello>
</div>
```

### 3. slot 和slot-scope

vue3中使用v-slot代替slot-scope

## 十三、模块化

通用的前端模块化规范：

1. commonJS模块化

   依赖环境，导入  导出

   export ， require

   ```javascript
   require('../aaa.css')
   ```

   

2. ES6模块化

   export（导出） import（导入）

   * 首先在js文件中加入type = module

     ````html
     <script src="aaa.js" type = "module"></script>
     <script src="bbb.js" type = "module"></script>
     ````

   * 在aaa.js中写好导出

     ```javascript
     export {flag,sum};	
     export let a = 100;
     export function test(){}
     export class Person{}
     //default后面的数量只有一个，同一个js文文件只有一个export default
     export default address 
     ```

   * 在bbb.js中导入就行了

     ```javascript
     import {flag ,sum} from 'aaa.js';
     import {a} from 'aaa.js';
     import * as aaa from 'aaa.js'
     ```

     

## 十四、webpack工具详解

​	webpack是一个现代的JavaScript应用的静态**模块**、**打包**工具

### 1. 前端模块化：

- ​	在ES6之前，我们要进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发
- 并且通过模块化开发完成了项目后，还需要处理模块见的各种依赖，并且将其进行**整合打包**
- ​	webpack其中一个核心就是让我们可能进行**模块化开发**，并且会**帮助我们处理模块间的依赖关系**。
- webpack不仅仅是JavaScript文件，相关的css、图片、json文件等等在webpack中都可以被当做模块来使用

1. 安装node

2. 安装webpack

   ```
   npm install webpack@3.6.0 -g
   ```

3. 建两个文件夹 src ，dist

   在src文件夹中开发，使用webpack打包到dist文件夹中

   ```
   webpack ./src/aaa.js ./dist/buddle.js
   ```

​	4. 后面直接引用dist中的buddle.js就可以了

### 2.webpackde配置文件

​	通过webpack配置文件，可以定义导出和导入，自动化一键导出，这个文件就是webpack.config.js

entry - 入口

output - 出口，这个后面的路径必须为绝对路径，写成path是为了通过node写绝对路径。通过命令 

```
npm init	
```

生成package.json.

```javascript
{
	'name':'meetwebpack',
    'version':'1.0.0',
    'description'：'',
     'main':'index.js'
    'script':{
	'test':'echo\"no test specified"&&exit 1',
     'build':'webpack'
    },
    'author':'',
     'license':'ISC'
    'devDependencies':{
        'webpack':"^3.6.0"
    }
}
```

package.json中定义了webpack与npm的映射，后面只需要执行npm run build 相当于执行 上面json文件中build后面的内容;

devDependencies 为开发式依赖，这个配置在 npm install webpack@3.6.0 --save-dev 自动生成

下面在webpack.config.js中定义出口入口

```javascript
const path = require('path')
module.exports = {
	entry:'./src/main.js',
	output:{
    	path:path.resolve(__dirname,'dist'),
    	filename:"buddle.js"
	}
}
```

可以知道，需要导出一个path的包，用来做路径； 这个地方运行下

```
npm install 
```

就可以添加依赖项，即path包了

main.js文件中，写明引用src中的 buddle.js 就行了



参考：https://webpack.docschina.org/concepts/

### 3.css文件处理

此时需要对webpack进行扩展，安装

```
npm install --save-dev css-loader
npm install --save-dev style-loader
```

在webpack.config.js中写明

```javascript
const path = require('path')
module.exports = {
	entry:'./src/main.js'
	output:{
    	path:path.resolve(__dirname,'dist')
    	filename:'buddle.js'
	},
  	module:{
        rules:[
            {	// 使用正则表达式匹配css文件
                test:'/\.css$/',
                // style-loader负责养殖添加到DOM中
                // css-loader只负责对css文件进行加载
                use:['style-loader','css-loader']
            }
        ]
    }
}

```



### 4.less文件处理

需要安装loader

```
npm install --save-dev less-loader less
```

### 5.图片处理

```
npm install --save-dev file-loader
npm install --save-dev url-loader
```

webpack会打包图片，其中图片名字会被hash成新名字，并放入dist文件夹中



### 6.es6转es5

```
npm install -D babel-loader @babel/core @babel/preset-env webpack
```

### 7.理解vue的组件化开发

https://www.bilibili.com/video/BV1H7411j7Mc?p=84&spm_id_from=pageDriver

### 8.html-webpack-plugin插件

**webpack.config.js**

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
const webpack = require('webpack'); // 访问内置的插件
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader',
      },
    ],
  },
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({ template: './src/index.html' }),
  ],
};
```

`ProgressPlugin` 用于自定义编译过程中的进度报告，`HtmlWebpackPlugin` 将生成一个 HTML 文件，并在其中使用 `script` 引入一个名为 `my-first-webpack.bundle.js` 的 JS 文件。

### 9. uglifyjs-webpack-plugin插件

丑化代码，用于压缩代码大小

**webpack.config.js**

```js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [new UglifyJsPlugin()],
  },
};
```

紧接着通过你的首选方式运行 `webpack`。

### 10.开发服务器(`devServer`) 

通过 [webpack-dev-server](https://github.com/webpack/webpack-dev-server) 的这些配置，能够以多种方式改变其行为。这是一个简单的示例，利用 `gzips` 压缩 `dist/` 目录当中的所有内容并提供一个本地服务(serve)：

**webpack.config.js**

```javascript
var path = require('path');

module.exports = {
  //...
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000,
  },
};
```

当服务(`server`)启动后，在解析模块列表之前输出一条消息：

```bash
http://localhost:9000/
webpack output is served from /build/
Content not from webpack is served from /path/to/dist/
```

这里将会给出服务启动位置以及内容的一些基本信息。

如果你通过 Node.js API 使用 dev-server，则 `devServer` 中的配置选项将被忽略。但可以将配置选项作为第二个参数传入：`new WebpackDevServer(compiler，{...})`。[此示例](https://github.com/webpack/webpack-dev-server/tree/master/examples/api/simple)展示了如何通过 Node.js API 使用 webpack-dev-server。

### 11.配置文件分离

首先建立build文件夹，用来存放分离后的的文件，开发配置文件、生产配置文件、基本配置文件

```
-- build
	|-- base.config.js
	|-- dev.config.js
	|-- prod.config.js
-- dist
-- src
-- package.json
```

第二步需要安装合并组件

````
npm install webpack-merge --save-dev
````

base.config.js

```javascript
module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
   module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: 'babel-loader',
      },
    ],
  }
}
```

prod.config.js

```javascript
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const webpackMerge = require('webpack-merge')
const baseConfig =require('./base.config.js')
module.exports = webpackMerge(baseConfig ,{
	plugins:[
	new UglifyJsPlugin()
	]
})
```

dev.config.js

```javascript
const webpackMerge = require('webpack-merge')
const baseConfig =require('./base.config.js')
module.exports =webpackMerge(baseConfig , {
	devServer:{
		contentBase:'./dist',
		inline:true
	}
})
```

合并基础配置base.config.js和prod.config.js内容，后输出

此时没有了webpack.config,js 文件，而是分解到了build文件夹下的三个文件，所以在编译的时候需要修改package.json文件：

* 修改build的路径
* 修改dev路径
* 返回去修改base.config.js中的路径，将./dist 修改为 ../dist，这样，重新打包生成的文件就在原来的dist文件夹下

package.json

```json
{
	'name':'meetwebpack',
    'version':'1.0.0',
    'description'：'',
     'main':'index.js'
    'script':{
	'test':'echo\"no test specified"&&exit 1',
     'build':'webpack --config ./build/prod.config.js'
     'dev':'webpack-dev-server  --open --config ./build/dev.config.js'
    },
    'author':'',
     'license':'ISC'
    'devDependencies':{
        'webpack':"^3.6.0"
    }
}
```

此时运行

```
// 执行打包
npm run build
npm run dev
```



## 十五、Vue CLI

### 1.脚手架 CLI

​	CLI -- Command-Line Interface，命令行界面，俗称脚手架

​	Vue CLI 是官方发布的vue.js项目脚手架

​	使用脚手架可以快速搭建Vue开发环境一级对应的webpack配置

### 2.使用前提 

​	Node、webpack

安装淘宝的cnpm

```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```



### 3.安装

```
//使用这个命令可以实现cnpm代替npm安装cli
npm install -g vue-cli
//下面这个用于cli3
npm install -g f@vue/cli
```

Vue CLI2初始化项目

```
vue init webpackage my-project
```

Vue CLI3初始化项目

```

vue create my-project
```



### 4.runtime-only和runtime-compiler

runtim-compiler需要的过程 ：  template --> ast(抽象语法树)-> render --> vdom(虚拟dom)-->UI

runtime-only 过程：render-> vdom -> UI

所以runtime-only更加快一些，choose it

https://www.bilibili.com/video/BV1H7411j7Mc?p=95&spm_id_from=pageDriver



### 5.vue-cli3

- vue-cli3 是基于webpack 4 打造， vue-cli 2 是基于webpack3打造
- vue-cli3的设计原则是 ‘0’配置，移除了配置文件根目录下的 build和config等目录
- vue-cli3 提供了vue ui命令，提供了可视化配置，更加人性化
- 移除了static文件夹，新增了public文件夹，并且index.html移动到了public中









